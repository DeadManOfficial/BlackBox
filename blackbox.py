#!/usr/bin/env python3
"""
BlackBox - DEADMAN Security Platform v5.3
==========================================

Portable, self-contained security research toolkit.

Usage:
    blackbox scan <target>          Run full scan pipeline
    blackbox recon <target>         Reconnaissance only
    blackbox report <project>       Generate report
    blackbox h1 <findings>          Convert to HackerOne drafts
    blackbox shell                  Interactive mode

Author: DeadManOfficial
"""

import sys
import json
import argparse
from pathlib import Path
from datetime import datetime

# Add modules to path
ROOT = Path(__file__).parent
sys.path.insert(0, str(ROOT))


def cmd_scan(args):
    """Run full scan pipeline."""
    from workflows.pipeline import PipelineOrchestrator, PipelinePhase

    project_name = args.project or f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    project_path = ROOT / "targets" / project_name

    auth = {'scope': args.scope} if args.scope else {'scope': 'authorized'}

    print(f"[*] BlackBox v5.3 - Scanning: {args.target}")
    print(f"[*] Project: {project_name}")

    orchestrator = PipelineOrchestrator(
        project_path=project_path,
        target=args.target,
        authorization=auth,
        scope_type="full"
    )

    stop_after = None
    if args.recon_only:
        stop_after = PipelinePhase.RECON
    elif args.scan_only:
        stop_after = PipelinePhase.SCAN

    result = orchestrator.run(stop_after=stop_after)
    print(f"\n[+] Complete. Results: {project_path}")
    return result


def cmd_recon(args):
    """Run reconnaissance only."""
    args.recon_only = True
    args.scan_only = False
    args.project = args.project or f"recon_{args.target.replace('.', '_')}"
    args.scope = getattr(args, 'scope', None)
    return cmd_scan(args)


def cmd_h1(args):
    """Convert findings to HackerOne drafts."""
    from modules.h1_bridge import H1Bridge

    print(f"[*] Converting findings: {args.findings}")

    bridge = H1Bridge(default_program=args.program or "")
    bridge.convert_findings(args.findings, program=args.program)

    output_dir = args.output or str(Path(args.findings).parent / "h1_drafts")
    paths = bridge.export_drafts(output_dir)

    print(f"[+] Generated {len(bridge.drafts)} drafts")
    print(f"[+] Output: {output_dir}")

    for draft in bridge.drafts:
        print(f"    [{draft.severity.upper()}] {draft.title[:60]}")

    return paths


def cmd_report(args):
    """Generate report from project."""
    project_path = ROOT / "targets" / args.project

    if not project_path.exists():
        print(f"[!] Project not found: {args.project}")
        return None

    findings_file = project_path / "findings.json"
    if not findings_file.exists():
        print(f"[!] No findings in project")
        return None

    with open(findings_file, 'r', encoding='utf-8') as f:
        data = json.load(f)

    findings = data.get('findings', data.get('vulnerabilities', []))

    # Count by severity
    sev_count = {}
    for f in findings:
        s = f.get('info', {}).get('severity', f.get('severity', 'info')).lower()
        sev_count[s] = sev_count.get(s, 0) + 1

    report = f"""# Security Assessment Report

**Project:** {args.project}
**Date:** {datetime.now().strftime('%Y-%m-%d')}
**Generated by:** BlackBox v5.3

## Summary

| Severity | Count |
|----------|-------|
| Critical | {sev_count.get('critical', 0)} |
| High     | {sev_count.get('high', 0)} |
| Medium   | {sev_count.get('medium', 0)} |
| Low      | {sev_count.get('low', 0)} |
| **Total**| **{len(findings)}** |

## Findings

"""
    for i, finding in enumerate(findings[:50], 1):
        info = finding.get('info', {})
        name = info.get('name', finding.get('name', 'Unknown'))
        sev = info.get('severity', finding.get('severity', 'info'))
        loc = finding.get('matched-at', finding.get('host', 'N/A'))
        report += f"### {i}. {name}\n\n"
        report += f"- **Severity:** {sev.upper()}\n"
        report += f"- **Location:** {loc}\n\n"

    report_path = project_path / "reports" / f"report_{datetime.now().strftime('%Y%m%d')}.md"
    report_path.parent.mkdir(parents=True, exist_ok=True)
    report_path.write_text(report, encoding='utf-8')

    print(f"[+] Report: {report_path}")
    return str(report_path)


def cmd_status(args):
    """Show BlackBox status and available tools."""
    import shutil

    print("=" * 50)
    print("BlackBox v5.3 - DEADMAN Security Platform")
    print("=" * 50)

    tools = {
        'nuclei': 'Vulnerability scanner',
        'httpx': 'HTTP prober',
        'subfinder': 'Subdomain discovery',
        'nmap': 'Port scanner',
        'ffuf': 'Fuzzer',
        'katana': 'Web crawler',
    }

    print("\n[Tools]")
    for tool, desc in tools.items():
        path = shutil.which(tool)
        status = "OK" if path else "NOT FOUND"
        print(f"  {tool:12} {status:10} {desc}")

    print("\n[Modules]")
    modules = ['signatures', 'oauth', 'hackerone', 'ai_security', 'adversary_emulation', 'h1_bridge']
    for mod in modules:
        try:
            __import__(f'modules.{mod}')
            print(f"  {mod:20} OK")
        except ImportError as e:
            print(f"  {mod:20} ERROR: {e}")

    print("\n[Directories]")
    dirs = ['targets', 'output', 'reports', 'config']
    for d in dirs:
        path = ROOT / d
        exists = "OK" if path.exists() else "MISSING"
        print(f"  {d:12} {exists}")

    print("=" * 50)


def cmd_shell(args):
    """Interactive shell mode."""
    print("BlackBox v5.3 Interactive Shell")
    print("Type 'help' for commands, 'exit' to quit\n")

    while True:
        try:
            cmd = input("blackbox> ").strip()
            if not cmd:
                continue
            if cmd in ('exit', 'quit', 'q'):
                break
            if cmd == 'help':
                print("  scan <target>    - Run scan")
                print("  recon <target>   - Run recon")
                print("  status           - Show status")
                print("  exit             - Quit")
            elif cmd == 'status':
                cmd_status(argparse.Namespace())
            elif cmd.startswith('scan '):
                target = cmd.split(' ', 1)[1]
                cmd_scan(argparse.Namespace(target=target, project=None, scope=None, recon_only=False, scan_only=False))
            elif cmd.startswith('recon '):
                target = cmd.split(' ', 1)[1]
                cmd_recon(argparse.Namespace(target=target, project=None))
            else:
                print(f"Unknown command: {cmd}")
        except KeyboardInterrupt:
            print("\n")
            break
        except Exception as e:
            print(f"Error: {e}")


def main():
    parser = argparse.ArgumentParser(
        description="BlackBox - DEADMAN Security Platform v5.3",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  blackbox scan example.com
  blackbox recon example.com --project myproject
  blackbox h1 targets/myproject/findings.json --program bugcrowd-target
  blackbox report myproject
  blackbox status
  blackbox shell
        """
    )

    subparsers = parser.add_subparsers(dest='command', help='Commands')

    # scan
    p_scan = subparsers.add_parser('scan', help='Run full scan pipeline')
    p_scan.add_argument('target', help='Target domain/URL')
    p_scan.add_argument('-p', '--project', help='Project name')
    p_scan.add_argument('-s', '--scope', help='Scope documentation')
    p_scan.add_argument('--recon-only', action='store_true', help='Stop after recon')
    p_scan.add_argument('--scan-only', action='store_true', help='Stop after scan')

    # recon
    p_recon = subparsers.add_parser('recon', help='Run reconnaissance only')
    p_recon.add_argument('target', help='Target domain')
    p_recon.add_argument('-p', '--project', help='Project name')

    # h1
    p_h1 = subparsers.add_parser('h1', help='Convert findings to HackerOne drafts')
    p_h1.add_argument('findings', help='Path to findings.json')
    p_h1.add_argument('--program', help='HackerOne program handle')
    p_h1.add_argument('-o', '--output', help='Output directory')

    # report
    p_report = subparsers.add_parser('report', help='Generate report')
    p_report.add_argument('project', help='Project name')

    # status
    subparsers.add_parser('status', help='Show status')

    # shell
    subparsers.add_parser('shell', help='Interactive mode')

    args = parser.parse_args()

    if args.command == 'scan':
        cmd_scan(args)
    elif args.command == 'recon':
        cmd_recon(args)
    elif args.command == 'h1':
        cmd_h1(args)
    elif args.command == 'report':
        cmd_report(args)
    elif args.command == 'status':
        cmd_status(args)
    elif args.command == 'shell':
        cmd_shell(args)
    else:
        parser.print_help()


if __name__ == '__main__':
    main()
