"""
Pentest Commander - Central Orchestrator
=========================================

Manages scan lifecycle, coordinates security agents, and handles
real-time vulnerability streaming.
"""

import asyncio
import logging
import json
import sqlite3
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
import sys
import os

# Add tools path dynamically based on project location
_PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
_TOOLS_PATH = os.environ.get('PENTEST_TOOLS_PATH', os.path.join(os.path.dirname(_PROJECT_ROOT), 'tools'))
if _TOOLS_PATH not in sys.path:
    sys.path.insert(0, _TOOLS_PATH)

from config import ScanParameters, DATABASE_PATH, SEVERITY_SCORES

logger = logging.getLogger(__name__)


class ScanPhase:
    """Scan phase constants"""
    INITIALIZATION = "INITIALIZATION"
    RECONNAISSANCE = "RECONNAISSANCE"
    VULNERABILITY_SCAN = "VULNERABILITY_SCAN"
    JS_ANALYSIS = "JS_ANALYSIS"
    LLM_SECURITY = "LLM_SECURITY"
    EXPLOIT_ANALYSIS = "EXPLOIT_ANALYSIS"
    SYNTHESIS = "SYNTHESIS"
    REPORTING = "REPORTING"
    COMPLETED = "COMPLETED"
    STOPPED = "STOPPED"


@dataclass
class ScanState:
    """Current scan state"""
    scan_id: str
    target: str
    phase: str = ScanPhase.INITIALIZATION
    progress: int = 0
    start_time: Optional[datetime] = None
    findings: List[Dict] = field(default_factory=list)
    agents_status: Dict[str, Dict] = field(default_factory=dict)
    attack_paths: List[Dict] = field(default_factory=list)
    is_running: bool = False
    error: Optional[str] = None

    @property
    def vulnerabilities_count(self) -> int:
        return len(self.findings)

    @property
    def severity_breakdown(self) -> Dict[str, int]:
        breakdown = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0}
        for finding in self.findings:
            sev = finding.get('severity', 'info').lower()
            if sev in breakdown:
                breakdown[sev] += 1
        return breakdown

    @property
    def risk_score(self) -> float:
        score = 0
        for finding in self.findings:
            sev = finding.get('severity', 'info').lower()
            score += SEVERITY_SCORES.get(sev, 0)
        return min(score, 100)


class PentestCommander:
    """
    Central orchestrator for penetration testing operations.

    Coordinates all security agents, manages scan phases, and
    streams results via WebSocket.
    """

    def __init__(self, socketio, scan_id: str):
        self.socketio = socketio
        self.scan_id = scan_id
        self.state = ScanState(scan_id=scan_id, target="")
        self.agents = {}
        self._stop_requested = False
        self._parameters = None

    async def execute_scan(self, parameters: ScanParameters):
        """Execute complete security scan"""
        self.state.target = parameters.target
        self.state.start_time = datetime.now()
        self.state.is_running = True
        self._parameters = parameters
        self._stop_requested = False

        logger.info(f"Starting scan against {parameters.target}")

        try:
            # Initialize agents
            await self._initialize_agents(parameters)

            # Phase 1: Reconnaissance
            if 'recon' in parameters.agents and not self._stop_requested:
                await self._execute_phase(ScanPhase.RECONNAISSANCE, 'recon')

            # Phase 2: Vulnerability Scanning
            if 'vulnerability' in parameters.agents and not self._stop_requested:
                await self._execute_phase(ScanPhase.VULNERABILITY_SCAN, 'vulnerability')

            # Phase 3: JS Analysis (if enabled)
            if parameters.js_analysis_enabled and 'vulnerability' in parameters.agents and not self._stop_requested:
                await self._execute_phase(ScanPhase.JS_ANALYSIS, 'vulnerability', task='js_analysis')

            # Phase 4: LLM Security Testing (if AI endpoint provided)
            if parameters.ai_endpoint and 'llm_security' in parameters.agents and not self._stop_requested:
                await self._execute_phase(ScanPhase.LLM_SECURITY, 'llm_security')

            # Phase 5: Exploit Analysis
            if 'exploit' in parameters.agents and not self._stop_requested:
                await self._execute_phase(ScanPhase.EXPLOIT_ANALYSIS, 'exploit')

            # Phase 6: Synthesis - correlate findings
            if 'synthesis' in parameters.agents and not self._stop_requested:
                await self._execute_phase(ScanPhase.SYNTHESIS, 'synthesis')

            # Phase 7: Generate attack paths
            if not self._stop_requested:
                await self._generate_attack_paths()

            # Complete
            if self._stop_requested:
                self.state.phase = ScanPhase.STOPPED
            else:
                self.state.phase = ScanPhase.COMPLETED
                self.state.progress = 100

            self._broadcast_status()

        except Exception as e:
            logger.error(f"Scan error: {e}")
            self.state.error = str(e)
            self._broadcast_alert('error', f"Scan error: {str(e)}")

        finally:
            self.state.is_running = False
            await self._save_final_results()

    async def _initialize_agents(self, parameters: ScanParameters):
        """Initialize security agents based on parameters"""
        from modules.security_agents import SecurityAgentFactory

        for agent_type in parameters.agents:
            try:
                agent = SecurityAgentFactory.create_agent(
                    agent_type,
                    parameters,
                    self._on_finding,
                    self._on_progress
                )
                self.agents[agent_type] = agent
                self.state.agents_status[agent_type] = {
                    'status': 'idle',
                    'current_task': 'Standby',
                    'progress': 0,
                    'findings_count': 0
                }
                logger.info(f"Initialized agent: {agent_type}")
            except Exception as e:
                logger.error(f"Failed to initialize agent {agent_type}: {e}")

        self._broadcast_status()

    async def _execute_phase(self, phase: str, agent_type: str, task: str = None):
        """Execute a scan phase with specified agent"""
        self.state.phase = phase
        self._broadcast_phase_change(phase)

        if agent_type not in self.agents:
            logger.warning(f"Agent {agent_type} not initialized")
            return

        agent = self.agents[agent_type]
        self.state.agents_status[agent_type]['status'] = 'active'
        self.state.agents_status[agent_type]['current_task'] = task or phase

        try:
            if task:
                await agent.execute_task(task)
            else:
                await agent.execute()
        except Exception as e:
            logger.error(f"Phase {phase} error: {e}")
            self.state.agents_status[agent_type]['status'] = 'error'
        else:
            self.state.agents_status[agent_type]['status'] = 'completed'

        self._broadcast_status()

    async def _generate_attack_paths(self):
        """Generate attack path visualization from findings"""
        self.state.phase = ScanPhase.REPORTING

        if not self.state.findings:
            return

        # Build attack graph from findings
        attack_path = {
            'nodes': [],
            'edges': [],
            'entry_points': [],
            'targets': []
        }

        # Group findings by severity for visualization
        critical_findings = [f for f in self.state.findings if f.get('severity') == 'critical']
        high_findings = [f for f in self.state.findings if f.get('severity') == 'high']

        # Add entry point (target)
        attack_path['nodes'].append({
            'id': 'entry',
            'label': self.state.target,
            'type': 'entry',
            'severity': 'info'
        })
        attack_path['entry_points'].append('entry')

        # Add critical vulnerabilities as potential targets
        for i, finding in enumerate(critical_findings[:5]):
            node_id = f'critical_{i}'
            attack_path['nodes'].append({
                'id': node_id,
                'label': finding.get('title', 'Unknown')[:30],
                'type': 'vulnerability',
                'severity': 'critical',
                'finding': finding
            })
            attack_path['edges'].append({
                'source': 'entry',
                'target': node_id,
                'weight': 1
            })
            attack_path['targets'].append(node_id)

        # Add high severity as intermediate steps
        for i, finding in enumerate(high_findings[:5]):
            node_id = f'high_{i}'
            attack_path['nodes'].append({
                'id': node_id,
                'label': finding.get('title', 'Unknown')[:30],
                'type': 'vulnerability',
                'severity': 'high',
                'finding': finding
            })
            attack_path['edges'].append({
                'source': 'entry',
                'target': node_id,
                'weight': 2
            })

            # Connect high to critical if exists
            if critical_findings:
                attack_path['edges'].append({
                    'source': node_id,
                    'target': f'critical_0',
                    'weight': 1
                })

        self.state.attack_paths.append(attack_path)

        # Store in database
        conn = sqlite3.connect(DATABASE_PATH)
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO attack_paths (scan_id, path_json, total_cost, stealth_score, timestamp)
            VALUES (?, ?, ?, ?, ?)
        ''', (
            self.scan_id,
            json.dumps(attack_path),
            len(attack_path['edges']),
            0.7,
            datetime.now().isoformat()
        ))
        conn.commit()
        conn.close()

        # Broadcast attack path update
        self.socketio.emit('attack_path_updated', {
            'scan_id': self.scan_id,
            'attack_path': attack_path
        })

    def _on_finding(self, finding: Dict):
        """Callback when agent discovers a finding"""
        finding['scan_id'] = self.scan_id
        finding['timestamp'] = datetime.now().isoformat()
        finding['finding_id'] = f"{self.scan_id}_{len(self.state.findings)}"

        self.state.findings.append(finding)

        # Store in database
        self._store_finding(finding)

        # Update agent finding count
        agent_id = finding.get('agent_id', 'unknown')
        if agent_id in self.state.agents_status:
            self.state.agents_status[agent_id]['findings_count'] += 1

        # Broadcast finding
        self.socketio.emit('vulnerability_found', {
            'scan_id': self.scan_id,
            'finding': finding
        })

        logger.info(f"Finding: [{finding.get('severity', 'info').upper()}] {finding.get('title', 'Unknown')}")

    def _on_progress(self, agent_id: str, progress: int, task: str = None):
        """Callback for agent progress updates"""
        if agent_id in self.state.agents_status:
            self.state.agents_status[agent_id]['progress'] = progress
            if task:
                self.state.agents_status[agent_id]['current_task'] = task

        # Calculate overall progress
        if self.agents:
            total_progress = sum(
                self.state.agents_status.get(a, {}).get('progress', 0)
                for a in self.agents
            )
            self.state.progress = total_progress // len(self.agents)

        self._broadcast_progress()

    def _store_finding(self, finding: Dict):
        """Store finding in database"""
        try:
            conn = sqlite3.connect(DATABASE_PATH)
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO findings (
                    finding_id, scan_id, agent_id, severity, title, description,
                    target_url, evidence, remediation, cvss_score, cve_id, timestamp, metadata
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                finding.get('finding_id'),
                finding.get('scan_id'),
                finding.get('agent_id'),
                finding.get('severity', 'info'),
                finding.get('title', 'Unknown'),
                finding.get('description', ''),
                finding.get('target_url', ''),
                finding.get('evidence', ''),
                finding.get('remediation', ''),
                finding.get('cvss_score'),
                finding.get('cve_id', ''),
                finding.get('timestamp'),
                json.dumps(finding.get('metadata', {}))
            ))
            conn.commit()
            conn.close()
        except Exception as e:
            logger.error(f"Failed to store finding: {e}")

    async def _save_final_results(self):
        """Save final scan results to database"""
        try:
            conn = sqlite3.connect(DATABASE_PATH)
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE scans SET
                    status = ?,
                    phase = ?,
                    vulnerabilities_count = ?,
                    end_time = ?
                WHERE scan_id = ?
            ''', (
                'completed' if not self._stop_requested else 'stopped',
                self.state.phase,
                self.state.vulnerabilities_count,
                datetime.now().isoformat(),
                self.scan_id
            ))
            conn.commit()
            conn.close()
        except Exception as e:
            logger.error(f"Failed to save results: {e}")

    def _broadcast_status(self):
        """Broadcast current status to all clients"""
        self.socketio.emit('scan_status', self.get_status())

    def _broadcast_phase_change(self, phase: str):
        """Broadcast phase change"""
        self.socketio.emit('scan_phase', {
            'scan_id': self.scan_id,
            'phase': phase,
            'timestamp': datetime.now().isoformat()
        })

    def _broadcast_progress(self):
        """Broadcast progress update"""
        self.socketio.emit('scan_progress', {
            'scan_id': self.scan_id,
            'progress': self.state.progress,
            'agents': self.state.agents_status
        })

    def _broadcast_alert(self, alert_type: str, message: str):
        """Broadcast system alert"""
        self.socketio.emit('system_alert', {
            'type': alert_type,
            'message': message,
            'timestamp': datetime.now().isoformat()
        })

    def get_status(self) -> Dict[str, Any]:
        """Get current scan status"""
        return {
            'scan_id': self.scan_id,
            'target': self.state.target,
            'phase': self.state.phase,
            'progress': self.state.progress,
            'is_running': self.state.is_running,
            'vulnerabilities_count': self.state.vulnerabilities_count,
            'severity_breakdown': self.state.severity_breakdown,
            'risk_score': self.state.risk_score,
            'agents': self.state.agents_status,
            'attack_paths_count': len(self.state.attack_paths),
            'start_time': self.state.start_time.isoformat() if self.state.start_time else None,
            'error': self.state.error
        }

    def get_agents_status(self) -> Dict[str, Dict]:
        """Get all agents status"""
        return self.state.agents_status

    def update_parameters(self, params: Dict):
        """Update scan parameters during execution"""
        if self._parameters:
            for key, value in params.items():
                if hasattr(self._parameters, key):
                    setattr(self._parameters, key, value)
        logger.info(f"Parameters updated: {params}")

    def stop(self):
        """Request scan stop"""
        self._stop_requested = True
        logger.info("Stop requested")
