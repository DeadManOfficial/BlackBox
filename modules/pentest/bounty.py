"""
Bounty Tracking System for DeadMan Pen.

Tracks bug bounty targets, payouts, and proof of concepts.
Integrates with the assessment workflow to prioritize targets.

RULEBOOK: ~/BlackBox/docs/BOUNTY_RULEBOOK.md
  - GATE_0 â†’ GATE_5 continuous flow
  - All tools mandatory, parallelized
  - Token optimization (T0-T4)
  - No halts, checkpoint and continue
"""

import csv
import json
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional
from enum import Enum

# Token optimization imports
try:
    from modules.utils.response_handler import truncate, summarize
    from modules.utils.gate_checkpoint import checkpoint, get_summary, GateCheckpoint
    from modules.utils.token_rules import TokenRules, BatchProcessor
    TOKEN_OPTIMIZATION_AVAILABLE = True
except ImportError:
    TOKEN_OPTIMIZATION_AVAILABLE = False


class BountySeverity(Enum):
    """Bounty severity tiers."""
    CRITICAL_TIER1 = 'CRITICAL (Tier 1)'
    HIGH_TIER2 = 'HIGH (Tier 2)'
    MEDIUM_TIER3 = 'MEDIUM (Tier 3)'
    LOW_TIER4 = 'LOW (Tier 4)'


class BountyStatus(Enum):
    """Bounty target status."""
    OPEN = 'Open'
    IN_PROGRESS = 'In Progress'
    FOUND = 'Found'
    SUBMITTED = 'Submitted'
    ACCEPTED = 'Accepted'
    DUPLICATE = 'Duplicate'
    INVALID = 'Invalid'
    PAID = 'Paid'


@dataclass
class BountyTarget:
    """Represents a bug bounty target."""
    target_asset: str
    severity: BountySeverity
    directive: str
    action: str
    status: BountyStatus = BountyStatus.OPEN
    assigned_to: Optional[str] = None
    cvss_score: Optional[float] = None
    payout: Optional[float] = None
    poc_link: Optional[str] = None
    notes: str = ''

    # Tracking fields
    findings: List[Dict[str, Any]] = field(default_factory=list)
    attack_paths: List[str] = field(default_factory=list)
    discovered_at: Optional[datetime] = None
    submitted_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'target_asset': self.target_asset,
            'severity': self.severity.value,
            'directive': self.directive,
            'action': self.action,
            'status': self.status.value,
            'assigned_to': self.assigned_to,
            'cvss_score': self.cvss_score,
            'payout': self.payout,
            'poc_link': self.poc_link,
            'notes': self.notes,
            'findings': self.findings,
            'attack_paths': self.attack_paths,
            'discovered_at': self.discovered_at.isoformat() if self.discovered_at else None,
            'submitted_at': self.submitted_at.isoformat() if self.submitted_at else None,
        }


# Mapping bounty targets to attack paths
BOUNTY_PATH_MAPPING = {
    'Non-Human Identities (NHI)': [
        'nhi_credential_extraction',
        'cicd_secrets',
        'js_analyze_batch',
        'ssrf_cloud_metadata',
    ],
    'Session Artifacts': [
        'session_exploitation',
        'jwt_escalation',
        'cors_auth_scan',
    ],
    'Identity Providers (IdP)': [
        'idp_trust_exploitation',
        'oauth_exploitation',
        'auth_flow_attack',
    ],
    'Backend Direct Access': [
        'supabase_exploitation',
        'firebase_exploitation',
        'backend_access_scan',
    ],
    'JWT Token Manipulation': [
        'jwt_escalation',
    ],
    'OAuth Flow Exploitation': [
        'oauth_exploitation',
    ],
    'Payment Logic Flaws': [
        'payment_exploitation',
    ],
    'AI/LLM Prompt Injection': [
        'ai_exploitation',
    ],
    'SSRF Cloud Metadata': [
        'ssrf_cloud_metadata',
    ],
    'GraphQL Security': [
        'graphql_exploitation',
    ],
}


class BountyTracker:
    """
    Tracks bug bounty targets and integrates with assessment workflow.
    """

    def __init__(self, bounty_file: str = "G:/deadman-pen/bounty.csv"):
        """Initialize bounty tracker."""
        self.bounty_file = Path(bounty_file)
        self.targets: List[BountyTarget] = []
        self._load_bounties()

    def _load_bounties(self) -> None:
        """Load bounties from CSV file."""
        if not self.bounty_file.exists():
            return

        with open(self.bounty_file, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    severity = BountySeverity(row.get('Severity', 'MEDIUM (Tier 3)'))
                except ValueError:
                    severity = BountySeverity.MEDIUM_TIER3

                try:
                    status = BountyStatus(row.get('Status', 'Open'))
                except ValueError:
                    status = BountyStatus.OPEN

                target = BountyTarget(
                    target_asset=row.get('Target Asset', ''),
                    severity=severity,
                    directive=row.get('Directive', ''),
                    action=row.get('Action', ''),
                    status=status,
                    assigned_to=row.get('Assigned To') or None,
                    cvss_score=float(row['CVSS Score']) if row.get('CVSS Score') else None,
                    payout=float(row['Payout ($)']) if row.get('Payout ($)') else None,
                    poc_link=row.get('Proof of Concept (Link)') or None,
                    notes=row.get('Notes', ''),
                )
                self.targets.append(target)

    def save_bounties(self) -> None:
        """Save bounties to CSV file."""
        fieldnames = [
            'Target Asset', 'Severity', 'Directive', 'Action', 'Status',
            'Assigned To', 'CVSS Score', 'Payout ($)', 'Proof of Concept (Link)', 'Notes'
        ]

        with open(self.bounty_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()

            for target in self.targets:
                writer.writerow({
                    'Target Asset': target.target_asset,
                    'Severity': target.severity.value,
                    'Directive': target.directive,
                    'Action': target.action,
                    'Status': target.status.value,
                    'Assigned To': target.assigned_to or '',
                    'CVSS Score': target.cvss_score or '',
                    'Payout ($)': target.payout or '',
                    'Proof of Concept (Link)': target.poc_link or '',
                    'Notes': target.notes,
                })

    def get_priority_targets(self) -> List[BountyTarget]:
        """Get targets sorted by priority (severity)."""
        priority_order = {
            BountySeverity.CRITICAL_TIER1: 0,
            BountySeverity.HIGH_TIER2: 1,
            BountySeverity.MEDIUM_TIER3: 2,
            BountySeverity.LOW_TIER4: 3,
        }

        open_targets = [t for t in self.targets if t.status == BountyStatus.OPEN]
        return sorted(open_targets, key=lambda t: priority_order.get(t.severity, 99))

    def get_attack_paths_for_target(self, target_asset: str) -> List[str]:
        """Get recommended attack paths for a bounty target."""
        return BOUNTY_PATH_MAPPING.get(target_asset, [])

    def update_target_status(self, target_asset: str, status: BountyStatus,
                             poc_link: Optional[str] = None,
                             payout: Optional[float] = None) -> bool:
        """Update bounty target status."""
        for target in self.targets:
            if target.target_asset == target_asset:
                target.status = status
                if poc_link:
                    target.poc_link = poc_link
                if payout:
                    target.payout = payout
                if status == BountyStatus.FOUND:
                    target.discovered_at = datetime.now()
                if status == BountyStatus.SUBMITTED:
                    target.submitted_at = datetime.now()
                self.save_bounties()
                return True
        return False

    def add_finding_to_target(self, target_asset: str,
                               finding: Dict[str, Any]) -> bool:
        """Add a finding to a bounty target."""
        for target in self.targets:
            if target.target_asset == target_asset:
                target.findings.append(finding)
                if target.status == BountyStatus.OPEN:
                    target.status = BountyStatus.IN_PROGRESS
                self.save_bounties()
                return True
        return False

    def get_target_by_asset(self, asset_name: str) -> Optional[BountyTarget]:
        """Get target by asset name."""
        for target in self.targets:
            if target.target_asset == asset_name:
                return target
        return None

    def get_targets_by_status(self, status: BountyStatus) -> List[BountyTarget]:
        """Get all targets with a specific status."""
        return [t for t in self.targets if t.status == status]

    def get_summary(self) -> Dict[str, Any]:
        """Get bounty tracking summary."""
        status_counts = {}
        severity_counts = {}
        total_payout = 0.0

        for target in self.targets:
            status_counts[target.status.value] = status_counts.get(target.status.value, 0) + 1
            severity_counts[target.severity.value] = severity_counts.get(target.severity.value, 0) + 1
            if target.payout:
                total_payout += target.payout

        return {
            'total_targets': len(self.targets),
            'status_counts': status_counts,
            'severity_counts': severity_counts,
            'total_payout': total_payout,
            'open_count': status_counts.get('Open', 0),
            'found_count': status_counts.get('Found', 0),
            'paid_count': status_counts.get('Paid', 0),
        }

    def export_json(self, path: str) -> None:
        """Export bounties to JSON."""
        data = {
            'targets': [t.to_dict() for t in self.targets],
            'summary': self.get_summary(),
            'exported_at': datetime.now().isoformat(),
        }
        with open(path, 'w') as f:
            json.dump(data, f, indent=2)

    # =====================================================================
    # Token Optimization Methods (T2, T3)
    # =====================================================================

    def checkpoint_gate(self, target: str, gate: str, data: Dict[str, Any]) -> str:
        """
        T2: Checkpoint after completing a bounty gate.

        Args:
            target: Target domain (e.g., "viewcreator.ai")
            gate: Gate identifier (e.g., "GATE_1", "INTEL")
            data: Gate results to checkpoint

        Returns:
            Summary string for context
        """
        if TOKEN_OPTIMIZATION_AVAILABLE:
            return checkpoint(target, gate, data)
        else:
            # Fallback: save to file
            path = Path.home() / "BlackBox" / "targets" / target / f"{gate}.json"
            path.parent.mkdir(parents=True, exist_ok=True)
            with open(path, 'w') as f:
                json.dump(data, f, indent=2, default=str)
            return f"{gate} saved to {path}"

    def get_gate_summary(self, target: str, gate: str) -> Optional[str]:
        """
        T3: Get compact summary of a completed gate.

        Returns summary string, not full data.
        """
        if TOKEN_OPTIMIZATION_AVAILABLE:
            return get_summary(target, gate)
        else:
            path = Path.home() / "BlackBox" / "targets" / target / f"{gate}.json"
            if path.exists():
                with open(path, 'r') as f:
                    data = json.load(f)
                return f"{gate}: {len(data)} items"
            return None

    def get_compact_summary(self) -> str:
        """
        T3: Get compact summary for context (not full data).

        Returns a minimal summary suitable for context window.
        """
        summary = self.get_summary()
        return (
            f"Targets: {summary['total_targets']} | "
            f"Open: {summary['open_count']} | "
            f"Found: {summary['found_count']} | "
            f"Paid: {summary['paid_count']} (${summary['total_payout']:.0f})"
        )

    def process_targets_batched(self, callback) -> List[Any]:
        """
        T4: Process targets in batches of 10.

        Args:
            callback: Function to call for each batch

        Returns:
            Combined results from all batches
        """
        results = []
        batch_size = 10

        for i in range(0, len(self.targets), batch_size):
            batch = self.targets[i:i + batch_size]
            batch_result = callback(batch)
            results.extend(batch_result if isinstance(batch_result, list) else [batch_result])

        return results

    # =====================================================================
    # Original Methods
    # =====================================================================

    def match_finding_to_target(self, finding: Dict[str, Any]) -> Optional[str]:
        """
        Match a finding to the most relevant bounty target.

        Returns the target asset name if matched.
        """
        finding_str = str(finding).lower()

        # Keyword matching
        keyword_mapping = {
            'Non-Human Identities (NHI)': [
                'api_key', 'secret', 'credential', 'token', 'service_principal',
                'oauth_token', 'ci/cd', 'build_log', 'env_var'
            ],
            'Session Artifacts': [
                'session', 'cookie', 'jwt', 'tgt', 'kerberos', 'golden_ticket',
                'session_timeout', 'session_hijack'
            ],
            'Identity Providers (IdP)': [
                'idp', 'saml', 'oidc', 'active_directory', 'shadow_admin',
                'delegated_permission', 'trust_relationship'
            ],
            'Backend Direct Access': [
                'supabase', 'firebase', 'direct_access', 'anon_key',
                'storage_bucket', 'database_query'
            ],
            'JWT Token Manipulation': [
                'jwt', 'algorithm_confusion', 'none_alg', 'claim_manipulation',
                'forged_token'
            ],
            'OAuth Flow Exploitation': [
                'oauth', 'open_redirect', 'state_fixation', 'token_leakage',
                'pkce_bypass'
            ],
            'Payment Logic Flaws': [
                'stripe', 'payment', 'checkout', 'webhook', 'trial_extension',
                'negative_value', 'currency_confusion'
            ],
            'AI/LLM Prompt Injection': [
                'prompt_injection', 'jailbreak', 'system_prompt', 'llm',
                'ai_security', 'crescendo'
            ],
            'SSRF Cloud Metadata': [
                'ssrf', 'cloud_metadata', 'iam_credential', 'aws_metadata',
                'gcp_metadata', 'azure_metadata'
            ],
            'GraphQL Security': [
                'graphql', 'introspection', 'batching', 'deep_query',
                'authorization_bypass'
            ],
        }

        best_match = None
        best_score = 0

        for target_asset, keywords in keyword_mapping.items():
            score = sum(1 for kw in keywords if kw in finding_str)
            if score > best_score:
                best_score = score
                best_match = target_asset

        return best_match if best_score > 0 else None
