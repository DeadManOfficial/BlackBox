"""
Decision Engine for DeadMan Pen.

Procedural if/then logic with automatic execution.
Rules are Python functions, not YAML declarations.
Decisions execute immediately without confirmation.
"""

import sys
import os

# Add parent directory to path for rules imports
_parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if _parent_dir not in sys.path:
    sys.path.insert(0, _parent_dir)

from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional, Union
from enum import Enum

from .state import (
    StateManager, Finding, AccessLevel, Severity, AssetType,
    AssessmentState, Decision
)
from .parser import ParsedResult, DetectedTechnology, TechStack


class PhaseType(Enum):
    """Assessment phases based on cyber kill chain."""
    P1_INTELLIGENCE = 'P1'      # Intelligence Gathering
    P2_WEAPONIZATION = 'P2'     # Weaponization
    P3_INITIAL_ACCESS = 'P3'    # Initial Access
    P4_EXECUTION = 'P4'         # Execution
    P5_ESCALATION = 'P5'        # Privilege Escalation
    P6_DISCOVERY = 'P6'         # Discovery
    P7_LATERAL = 'P7'           # Lateral Movement
    P8_EXFILTRATION = 'P8'      # Exfiltration
    P9_AI_INFLUENCE = 'P9'      # AI Influence Operations


@dataclass
class PhaseTransition:
    """Represents a phase transition decision."""
    from_phase: str
    to_phase: str
    priority: int = 50
    parallel: bool = False
    reason: str = ''
    context_updates: Dict[str, Any] = field(default_factory=dict)
    tools: List[str] = field(default_factory=list)

    @classmethod
    def stay(cls, phase: str, reason: str = '') -> 'PhaseTransition':
        """Create a stay-in-current-phase transition."""
        return cls(from_phase=phase, to_phase=phase, reason=reason)

    @classmethod
    def continue_phase(cls, phase: str, tools: List[str],
                       reason: str = '') -> 'PhaseTransition':
        """Continue current phase with specific tools."""
        return cls(
            from_phase=phase,
            to_phase=phase,
            tools=tools,
            reason=reason
        )


@dataclass
class ToolExecution:
    """Represents a tool to be executed."""
    tool: str
    params: Dict[str, Any] = field(default_factory=dict)
    priority: int = 50
    timeout: Optional[int] = None


@dataclass
class ConditionalTool:
    """A tool that executes only if condition is met."""
    condition: Callable[[Dict[str, Any]], bool]
    tool: str
    params: Dict[str, Any] = field(default_factory=dict)
    action: Optional[Callable] = None  # Alternative action instead of tool


@dataclass
class ToolChain:
    """A chain of tools to execute in sequence."""
    tools: List[Union[ToolExecution, ConditionalTool]]

    def resolve(self, results: Dict[str, Any]) -> List[ToolExecution]:
        """Resolve conditional tools based on previous results."""
        resolved = []
        for item in self.tools:
            if isinstance(item, ToolExecution):
                resolved.append(item)
            elif isinstance(item, ConditionalTool):
                if item.condition(results):
                    if item.action:
                        item.action(results)
                    else:
                        resolved.append(ToolExecution(
                            tool=item.tool,
                            params=item.params
                        ))
        return resolved


@dataclass
class AttackPath:
    """Represents an attack path to execute."""
    name: str
    tools: List[ToolExecution]
    priority: int = 50
    success_condition: Optional[Callable[[Dict[str, Any]], bool]] = None


@dataclass
class EscalationPath:
    """Represents a privilege escalation path."""
    name: str
    tools: List[tuple]  # List of (tool_name, params) tuples
    success_condition: Callable[[Dict[str, Any]], bool]
    target_access: AccessLevel = AccessLevel.ADMIN


@dataclass
class AssessmentContext:
    """Current assessment context for decision making."""
    assessment_id: int
    target: str
    domain: Optional[str]
    current_phase: str

    # Detected information
    tech_stack: List[DetectedTechnology] = field(default_factory=list)
    endpoints: List[str] = field(default_factory=list)
    js_bundles: List[str] = field(default_factory=list)
    subdomains: List[str] = field(default_factory=list)

    # Access state
    access_level: AccessLevel = AccessLevel.ANONYMOUS
    credentials: Dict[str, Any] = field(default_factory=dict)
    jwt_tokens: List[str] = field(default_factory=list)

    # Backend detection
    supabase_url: Optional[str] = None
    firebase_project: Optional[str] = None
    has_backend_access: bool = False
    has_backend_direct_access: bool = False

    # AI detection
    ai_endpoints: List[str] = field(default_factory=list)
    ai_models: List[str] = field(default_factory=list)

    # OAuth detection
    oauth_endpoints: List[str] = field(default_factory=list)
    oauth_tokens: List[str] = field(default_factory=list)

    # Payment detection
    checkout_endpoint: Optional[str] = None
    webhook_endpoint: Optional[str] = None
    api_base: Optional[str] = None

    # User endpoints
    user_endpoint: Optional[str] = None
    user_id_params: List[str] = field(default_factory=list)

    # Findings and intel
    findings: List[Finding] = field(default_factory=list)
    intel_findings: Dict[str, Any] = field(default_factory=dict)
    vulns_found: bool = False
    extracted_keys: Dict[str, str] = field(default_factory=dict)

    # Metadata
    target_url: Optional[str] = None
    observed_checkout_payload: Dict[str, Any] = field(default_factory=dict)

    def has_technology(self, tech_name: str) -> bool:
        """Check if a technology was detected."""
        return any(t.name.lower() == tech_name.lower() for t in self.tech_stack)

    def has_tech_category(self, category: TechStack) -> bool:
        """Check if any technology of a category was detected."""
        return any(t.category == category for t in self.tech_stack)

    def get_severity_counts(self) -> Dict[str, int]:
        """Get counts of findings by severity."""
        counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0}
        for finding in self.findings:
            severity = finding.severity.value if hasattr(finding.severity, 'value') else str(finding.severity)
            if severity in counts:
                counts[severity] += 1
        return counts

    def escalate(self, escalation_type: str, severity: str = 'high') -> None:
        """Mark an escalation event."""
        # This would trigger logging/notification
        pass


class DecisionEngine:
    """
    Procedural rule evaluation with automatic execution.

    Rules are Python functions, not YAML declarations.
    Decisions execute immediately without confirmation.
    """

    def __init__(self, state_manager: StateManager, config: Dict[str, Any] = None):
        """Initialize the decision engine."""
        self.state = state_manager
        self.config = config or {}
        self._rule_registry: Dict[str, Callable] = {}

    def register_rule(self, name: str, rule_fn: Callable) -> None:
        """Register a decision rule function."""
        self._rule_registry[name] = rule_fn

    def build_context(self, assessment_id: int) -> AssessmentContext:
        """Build assessment context from current state."""
        assessment = self.state.get_assessment(assessment_id)
        if not assessment:
            raise ValueError(f"Assessment {assessment_id} not found")

        findings = self.state.get_findings(assessment_id)
        access_records = self.state.get_access_records(assessment_id)
        assets = self.state.get_assets(assessment_id)
        highest_access = self.state.get_highest_access(assessment_id)

        # Build context
        ctx = AssessmentContext(
            assessment_id=assessment_id,
            target=assessment['target'],
            domain=assessment.get('domain'),
            current_phase=assessment['current_phase'],
            access_level=highest_access or AccessLevel.ANONYMOUS,
            findings=findings,
            vulns_found=len(findings) > 0,
        )

        # Extract technologies from findings
        for finding in findings:
            if finding.evidence:
                # Check for technology indicators
                evidence_str = str(finding.evidence)
                self._extract_tech_from_evidence(ctx, evidence_str)

        # Extract credentials from access records
        for access in access_records:
            if access.credentials:
                ctx.credentials.update(access.credentials)
                if 'jwt' in access.credentials:
                    ctx.jwt_tokens.append(access.credentials['jwt'])

        # Extract keys from assets
        for asset in assets:
            if asset.type == AssetType.API_KEY and asset.metadata:
                ctx.extracted_keys.update(asset.metadata)

        return ctx

    def _extract_tech_from_evidence(self, ctx: AssessmentContext, evidence: str) -> None:
        """Extract technology indicators from evidence."""
        evidence_lower = evidence.lower()

        if 'supabase' in evidence_lower:
            ctx.has_backend_access = True
            # Try to extract URL
            import re
            match = re.search(r'https?://[a-z0-9-]+\.supabase\.\w+', evidence_lower)
            if match:
                ctx.supabase_url = match.group(0)

        if 'firebase' in evidence_lower:
            ctx.has_backend_access = True
            match = re.search(r'[a-z0-9-]+-[a-z0-9]+\.firebaseio\.com', evidence_lower)
            if match:
                ctx.firebase_project = match.group(0)

        if 'openai' in evidence_lower or 'gpt' in evidence_lower:
            match = re.search(r'https?://[^\s"\']+', evidence)
            if match and 'api' in match.group(0).lower():
                ctx.ai_endpoints.append(match.group(0))

        if 'stripe' in evidence_lower:
            ctx.has_tech_category = True

    def evaluate_phase_transition(self, ctx: AssessmentContext) -> List[PhaseTransition]:
        """
        Evaluate phase transitions based on current context.

        IF findings meet criteria THEN transition to next phase
        ELSE continue current phase or branch to alternative
        """
        transitions = []

        # Import phase rules dynamically to avoid circular imports
        from rules import phase_rules

        # Get transition function for current phase
        transition_fn_name = f"evaluate_{ctx.current_phase.lower()}_transition"
        if hasattr(phase_rules, transition_fn_name):
            transition_fn = getattr(phase_rules, transition_fn_name)
            result = transition_fn(ctx)
            if isinstance(result, list):
                transitions.extend(result)
            elif result:
                transitions.append(result)

        # Check for parallel branch opportunities
        parallel_branches = self._evaluate_parallel_branches(ctx)
        transitions.extend(parallel_branches)

        # If no transitions, stay in current phase
        if not transitions:
            transitions.append(PhaseTransition.stay(
                ctx.current_phase,
                reason='No transition conditions met'
            ))

        return sorted(transitions, key=lambda t: t.priority, reverse=True)

    def _evaluate_parallel_branches(self, ctx: AssessmentContext) -> List[PhaseTransition]:
        """Evaluate opportunities for parallel phase execution."""
        branches = []

        # IF AI endpoints detected AND not in P9 THEN branch to P9
        if ctx.ai_endpoints and ctx.current_phase != 'P9':
            branches.append(PhaseTransition(
                from_phase=ctx.current_phase,
                to_phase='P9',
                priority=70,
                parallel=True,
                reason='AI endpoints detected',
                context_updates={'ai_endpoints': ctx.ai_endpoints}
            ))

        # IF backend direct access AND not in P6/P8 THEN branch
        if ctx.has_backend_direct_access and ctx.current_phase not in ['P6', 'P8']:
            branches.append(PhaseTransition(
                from_phase=ctx.current_phase,
                to_phase='P6',
                priority=85,
                parallel=True,
                reason='Direct backend access available'
            ))

        return branches

    def evaluate_tool_selection(self, ctx: AssessmentContext) -> List[ToolExecution]:
        """
        Select tools to run based on current context.

        IF technology X detected THEN run tools [A, B, C] in parallel
        IF finding Y present THEN escalate with tool D
        """
        tools = []

        # Import tech rules dynamically
        from rules import tech_rules

        # Technology-specific tools
        for tech in ctx.tech_stack:
            tech_fn_name = f"{tech.name.lower()}_detected"
            if hasattr(tech_rules, tech_fn_name):
                tech_fn = getattr(tech_rules, tech_fn_name)
                chain = tech_fn(ctx)
                if isinstance(chain, ToolChain):
                    tools.extend(chain.tools)
                elif isinstance(chain, list):
                    tools.extend(chain)
                elif chain:
                    tools.append(chain)

        # Phase-specific base tools
        phase_tools = self._get_phase_tools(ctx.current_phase)
        tools.extend(phase_tools)

        # Deduplicate while preserving order
        seen = set()
        unique_tools = []
        for tool in tools:
            key = (tool.tool if isinstance(tool, ToolExecution) else tool, str(tool.params if isinstance(tool, ToolExecution) else {}))
            if key not in seen:
                seen.add(key)
                unique_tools.append(tool)

        return unique_tools

    def _get_phase_tools(self, phase: str) -> List[ToolExecution]:
        """Get base tools for a phase from config."""
        phase_config = self.config.get('phases', {})

        # Map phase code to config key
        phase_map = {
            'P1': 'P1_intelligence',
            'P2': 'P2_weaponization',
            'P3': 'P3_initial_access',
            'P4': 'P4_execution',
            'P5': 'P5_privilege_escalation',
            'P6': 'P6_discovery',
            'P7': 'P7_lateral_movement',
            'P8': 'P8_exfiltration',
            'P9': 'P9_ai_influence',
        }

        config_key = phase_map.get(phase, phase)
        phase_data = phase_config.get(config_key, {})
        tool_names = phase_data.get('tools', [])

        return [ToolExecution(tool=name, params={}) for name in tool_names]

    def evaluate_path_branch(self, ctx: AssessmentContext) -> List[AttackPath]:
        """
        Evaluate viable attack paths from current state.

        IF multiple viable paths THEN execute ALL in parallel
        ELSE follow highest-priority path
        """
        paths = []

        # Check for various attack vectors based on context

        # JWT attacks
        if ctx.jwt_tokens:
            paths.append(AttackPath(
                name='jwt_exploitation',
                tools=[
                    ToolExecution('jwt_analyze', {
                        'token': ctx.jwt_tokens[0],
                        'testNoneAlg': True,
                        'testAlgConfusion': True
                    })
                ],
                priority=80,
                success_condition=lambda r: r.get('elevated_claims')
            ))

        # IDOR attacks
        if ctx.user_id_params:
            for param in ctx.user_id_params[:3]:  # Limit to 3 params
                paths.append(AttackPath(
                    name=f'idor_{param}',
                    tools=[
                        ToolExecution('idor_scan', {
                            'url': ctx.user_endpoint,
                            'param': param,
                            'testType': 'sequential'
                        })
                    ],
                    priority=70,
                    success_condition=lambda r: r.get('unauthorized_access')
                ))

        # OAuth attacks
        if ctx.oauth_endpoints:
            paths.append(AttackPath(
                name='oauth_exploitation',
                tools=[
                    ToolExecution('oauth_scan', {
                        'authUrl': ctx.oauth_endpoints[0],
                        'categories': ['open_redirect', 'state_fixation', 'token_leakage']
                    })
                ],
                priority=75,
                success_condition=lambda r: r.get('token_captured')
            ))

        # Backend direct access
        if ctx.supabase_url:
            paths.append(AttackPath(
                name='supabase_exploitation',
                tools=[
                    ToolExecution('backend_access_scan', {
                        'service': 'supabase',
                        'url': ctx.supabase_url,
                        'anon_key': ctx.extracted_keys.get('supabase_anon')
                    })
                ],
                priority=90,
                success_condition=lambda r: r.get('direct_api_access')
            ))

        if ctx.firebase_project:
            paths.append(AttackPath(
                name='firebase_exploitation',
                tools=[
                    ToolExecution('backend_access_scan', {
                        'service': 'firebase',
                        'project_id': ctx.firebase_project
                    })
                ],
                priority=90,
                success_condition=lambda r: r.get('direct_api_access')
            ))

        # AI attacks
        if ctx.ai_endpoints:
            for endpoint in ctx.ai_endpoints[:2]:  # Limit to 2 endpoints
                paths.append(AttackPath(
                    name=f'ai_exploitation_{hash(endpoint) % 1000}',
                    tools=[
                        ToolExecution('ai_security_test', {
                            'url': endpoint,
                            'categories': ['prompt_injection', 'jailbreak', 'system_prompt_leak']
                        }),
                        ToolExecution('llm_redteam_scan', {
                            'targetUrl': endpoint,
                            'strategies': ['direct', 'multi_turn']
                        })
                    ],
                    priority=65,
                    success_condition=lambda r: r.get('vulnerabilities')
                ))

        # Payment attacks
        if ctx.checkout_endpoint:
            paths.append(AttackPath(
                name='payment_exploitation',
                tools=[
                    ToolExecution('payment_injection_scan', {
                        'url': ctx.checkout_endpoint,
                        'base_payload': ctx.observed_checkout_payload
                    }),
                    ToolExecution('payment_security_test', {
                        'url': ctx.checkout_endpoint,
                        'categories': ['negative_value', 'currency_confusion']
                    })
                ],
                priority=85,
                success_condition=lambda r: r.get('vulnerabilities')
            ))

        return sorted(paths, key=lambda p: p.priority, reverse=True)

    def evaluate_escalation_paths(self, ctx: AssessmentContext) -> List[EscalationPath]:
        """
        Evaluate ALL possible privilege escalation vectors.
        """
        from rules import escalation_rules

        if hasattr(escalation_rules, 'evaluate_escalation_paths'):
            return escalation_rules.evaluate_escalation_paths(ctx)

        return []

    def log_decision(self, assessment_id: int, rule_name: str,
                     condition_met: str, action_taken: str,
                     context_before: Dict[str, Any],
                     context_after: Dict[str, Any]) -> None:
        """Log a decision to the audit trail."""
        decision = Decision(
            rule_name=rule_name,
            condition_met=condition_met,
            action_taken=action_taken,
            context_before=context_before,
            context_after=context_after
        )
        self.state.log_decision(assessment_id, decision)

    def should_continue(self, ctx: AssessmentContext) -> bool:
        """
        Determine if assessment should continue.

        Returns False if:
        - All goals are met
        - Time/resource limits exceeded
        - Manual stop requested
        """
        # Check if assessment is paused/stopped
        assessment = self.state.get_assessment(ctx.assessment_id)
        if assessment and assessment['status'] != 'active':
            return False

        # Goals will be checked by GoalTracker
        return True

    def get_next_actions(self, ctx: AssessmentContext) -> Dict[str, Any]:
        """
        Get all next actions to take based on current context.

        Returns dict with:
        - transitions: Phase transitions to make
        - tools: Tools to execute
        - paths: Attack paths to explore
        - escalations: Escalation attempts to make
        """
        return {
            'transitions': self.evaluate_phase_transition(ctx),
            'tools': self.evaluate_tool_selection(ctx),
            'paths': self.evaluate_path_branch(ctx),
            'escalations': self.evaluate_escalation_paths(ctx),
        }
