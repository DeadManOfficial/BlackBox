"""
Privilege Escalation Rules for DeadMan Pen.

Rules that evaluate and execute privilege escalation paths.
Executes ALL viable escalation vectors in parallel.
"""

from typing import List
from dataclasses import dataclass, field


@dataclass
class EscalationPath:
    """Represents a privilege escalation path."""
    name: str
    tools: list  # List of (tool_name, params) tuples
    success_condition: callable
    target_access: str = 'admin'  # anonymous, user, admin, root
    priority: int = 50


def evaluate_escalation_paths(ctx) -> List[EscalationPath]:
    """
    Evaluate ALL possible privilege escalation vectors.
    Execute in parallel, tracking which succeed.
    """
    paths = []

    # ==========================================================================
    # JWT-Based Escalation
    # ==========================================================================
    if ctx.jwt_tokens:
        paths.append(EscalationPath(
            name='jwt_none_algorithm',
            tools=[
                ('jwt_analyze', {'token': ctx.jwt_tokens[0], 'testNoneAlg': True})
            ],
            success_condition=lambda r: r.get('none_alg_vulnerable') or r.get('elevated_claims'),
            priority=85
        ))

        paths.append(EscalationPath(
            name='jwt_algorithm_confusion',
            tools=[
                ('jwt_analyze', {'token': ctx.jwt_tokens[0], 'testAlgConfusion': True})
            ],
            success_condition=lambda r: r.get('alg_confusion_vulnerable'),
            priority=80
        ))

        paths.append(EscalationPath(
            name='jwt_claim_manipulation',
            tools=[
                ('jwt_analyze', {'token': ctx.jwt_tokens[0], 'testClaimManipulation': True})
            ],
            success_condition=lambda r: r.get('claims_modifiable'),
            priority=75
        ))

    # ==========================================================================
    # IDOR-Based Escalation
    # ==========================================================================
    if ctx.user_id_params:
        for param in ctx.user_id_params[:5]:  # Test up to 5 parameters
            paths.append(EscalationPath(
                name=f'idor_sequential_{param}',
                tools=[
                    ('idor_scan', {
                        'url': ctx.user_endpoint or ctx.target_url,
                        'param': param,
                        'testType': 'sequential'
                    })
                ],
                success_condition=lambda r: r.get('unauthorized_access'),
                priority=70
            ))

            paths.append(EscalationPath(
                name=f'idor_uuid_{param}',
                tools=[
                    ('idor_scan', {
                        'url': ctx.user_endpoint or ctx.target_url,
                        'param': param,
                        'testType': 'uuid_manipulation'
                    })
                ],
                success_condition=lambda r: r.get('unauthorized_access'),
                priority=65
            ))

    # ==========================================================================
    # OAuth-Based Escalation
    # ==========================================================================
    if ctx.oauth_endpoints:
        paths.append(EscalationPath(
            name='oauth_scope_escalation',
            tools=[
                ('oauth_scan', {
                    'authUrl': ctx.oauth_endpoints[0],
                    'categories': ['scope_manipulation']
                })
            ],
            success_condition=lambda r: r.get('elevated_scope'),
            priority=75
        ))

        paths.append(EscalationPath(
            name='oauth_token_theft',
            tools=[
                ('oauth_scan', {
                    'authUrl': ctx.oauth_endpoints[0],
                    'categories': ['token_leakage', 'open_redirect']
                })
            ],
            success_condition=lambda r: r.get('token_captured'),
            priority=80
        ))

    # ==========================================================================
    # Backend Direct Access Escalation
    # ==========================================================================
    if ctx.has_backend_access or ctx.has_backend_direct_access:
        paths.append(EscalationPath(
            name='backend_admin_escalation',
            tools=[
                ('backend_access_scan', {'test_admin': True}),
                ('api_enumerate', {'paths': ['/admin/', '/internal/', '/rpc/', '/management/']})
            ],
            success_condition=lambda r: r.get('admin_access') or r.get('internal_access'),
            target_access='admin',
            priority=90
        ))

        paths.append(EscalationPath(
            name='backend_rpc_escalation',
            tools=[
                ('api_enumerate', {'paths': ['/rpc/', '/graphql/', '/internal/']})
            ],
            success_condition=lambda r: r.get('rpc_access'),
            priority=85
        ))

    # ==========================================================================
    # Race Condition Escalation
    # ==========================================================================
    paths.append(EscalationPath(
        name='race_condition_double_spend',
        tools=[
            ('race_condition_scan', {
                'url': ctx.target_url,
                'type': 'double_spend'
            })
        ],
        success_condition=lambda r: r.get('race_successful'),
        priority=65
    ))

    paths.append(EscalationPath(
        name='race_condition_limit_bypass',
        tools=[
            ('race_condition_scan', {
                'url': ctx.target_url,
                'type': 'limit_bypass'
            })
        ],
        success_condition=lambda r: r.get('limit_bypassed'),
        priority=60
    ))

    # ==========================================================================
    # CORS-Based Escalation
    # ==========================================================================
    paths.append(EscalationPath(
        name='cors_credential_theft',
        tools=[
            ('cors_auth_scan', {
                'url': ctx.target_url,
                'auth_token': ctx.jwt_tokens[0] if ctx.jwt_tokens else None
            })
        ],
        success_condition=lambda r: r.get('exploitable_cors'),
        priority=70
    ))

    # ==========================================================================
    # SSRF-Based Escalation (Cloud Metadata)
    # ==========================================================================
    paths.append(EscalationPath(
        name='ssrf_cloud_metadata',
        tools=[
            ('ssrf_scan', {
                'targetUrl': ctx.target_url,
                'param': 'url',
                'clouds': ['aws', 'gcp', 'azure']
            })
        ],
        success_condition=lambda r: r.get('cloud_metadata') or r.get('iam_credentials'),
        target_access='root',
        priority=95
    ))

    # ==========================================================================
    # Session Fixation/Hijacking
    # ==========================================================================
    paths.append(EscalationPath(
        name='session_fixation',
        tools=[
            ('auth_flow_attack', {'attackType': 'session_fixation'})
        ],
        success_condition=lambda r: r.get('session_fixable'),
        priority=60
    ))

    # ==========================================================================
    # Mass Assignment Escalation
    # ==========================================================================
    paths.append(EscalationPath(
        name='mass_assignment',
        tools=[
            ('auth_flow_attack', {'attackType': 'mass_assignment'})
        ],
        success_condition=lambda r: r.get('role_elevated'),
        target_access='admin',
        priority=75
    ))

    # ==========================================================================
    # Password Reset Flow Exploitation
    # ==========================================================================
    paths.append(EscalationPath(
        name='password_reset_poisoning',
        tools=[
            ('host_header_scan', {
                'targetUrl': ctx.target_url,
                'testPasswordReset': True
            })
        ],
        success_condition=lambda r: r.get('reset_poisoned'),
        target_access='admin',
        priority=70
    ))

    # ==========================================================================
    # GraphQL Authorization Bypass
    # ==========================================================================
    if ctx.has_technology('graphql') or hasattr(ctx, 'graphql_endpoint'):
        paths.append(EscalationPath(
            name='graphql_auth_bypass',
            tools=[
                ('graphql_scan', {
                    'graphqlUrl': getattr(ctx, 'graphql_endpoint', ctx.target_url),
                    'testAuthBypass': True
                })
            ],
            success_condition=lambda r: r.get('auth_bypassed'),
            target_access='admin',
            priority=80
        ))

    # ==========================================================================
    # Cache Deception for Session
    # ==========================================================================
    paths.append(EscalationPath(
        name='cache_deception',
        tools=[
            ('cache_poisoning_scan', {
                'targetUrl': ctx.target_url,
                'testCacheDeception': True
            })
        ],
        success_condition=lambda r: r.get('session_cached'),
        priority=55
    ))

    # ==========================================================================
    # HTTP Smuggling for Auth Bypass
    # ==========================================================================
    paths.append(EscalationPath(
        name='http_smuggling_auth_bypass',
        tools=[
            ('http_smuggling_scan', {
                'targetUrl': ctx.target_url,
                'testClTe': True,
                'testTeCl': True
            })
        ],
        success_condition=lambda r: r.get('smuggling_successful'),
        target_access='admin',
        priority=50
    ))

    # Sort by priority
    return sorted(paths, key=lambda p: p.priority, reverse=True)


def get_escalation_strategy(ctx) -> str:
    """
    Determine best escalation strategy based on context.

    Returns strategy name: 'jwt', 'idor', 'oauth', 'backend', 'session', 'cloud'
    """
    # Score each strategy
    scores = {
        'jwt': 0,
        'idor': 0,
        'oauth': 0,
        'backend': 0,
        'session': 0,
        'cloud': 0,
    }

    if ctx.jwt_tokens:
        scores['jwt'] += 30
        # If JWT looks weak (short, base64 padding issues)
        if any(len(t) < 200 for t in ctx.jwt_tokens):
            scores['jwt'] += 20

    if ctx.user_id_params:
        scores['idor'] += len(ctx.user_id_params) * 10

    if ctx.oauth_endpoints:
        scores['oauth'] += 25

    if ctx.has_backend_access or ctx.has_backend_direct_access:
        scores['backend'] += 40

    if ctx.credentials:
        scores['session'] += 20

    # Cloud indicators
    if ctx.has_technology('aws') or ctx.has_technology('gcp') or ctx.has_technology('azure'):
        scores['cloud'] += 35

    # Return highest scoring strategy
    return max(scores, key=scores.get)


def get_priority_escalation_tools(ctx) -> list:
    """
    Get prioritized list of escalation tools based on context.
    """
    strategy = get_escalation_strategy(ctx)

    tool_priority = {
        'jwt': ['jwt_analyze', 'cors_auth_scan'],
        'idor': ['idor_scan', 'api_enumerate'],
        'oauth': ['oauth_scan', 'auth_flow_attack'],
        'backend': ['backend_access_scan', 'db_error_exploit', 'api_enumerate'],
        'session': ['race_condition_scan', 'cors_auth_scan', 'host_header_scan'],
        'cloud': ['ssrf_scan', 'cloud_storage_enum'],
    }

    return tool_priority.get(strategy, [])
