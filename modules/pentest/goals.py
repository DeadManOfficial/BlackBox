"""
Goal Tracking System for DeadMan Pen.

Tracks ALL goals simultaneously:
- Access Level Gates (anon -> user -> admin -> root)
- Asset Acquisition (db dump, source code, API keys, PII)
- Vulnerability Count (critical, high, medium thresholds)
- Full Enumeration (exhaust all paths)
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set
from enum import Enum
from abc import ABC, abstractmethod

from .state import StateManager, AccessLevel, AssetType, Severity


class GoalStatus(Enum):
    """Status of a goal."""
    NOT_STARTED = 'not_started'
    IN_PROGRESS = 'in_progress'
    COMPLETED = 'completed'
    PARTIALLY_MET = 'partially_met'
    FAILED = 'failed'


@dataclass
class GoalProgress:
    """Progress tracking for a goal."""
    goal_name: str
    status: GoalStatus
    current_value: Any
    target_value: Any
    percentage: float
    details: Dict[str, Any] = field(default_factory=dict)


class Goal(ABC):
    """Abstract base class for goals."""

    @property
    @abstractmethod
    def name(self) -> str:
        """Goal name."""
        pass

    @abstractmethod
    def check_progress(self, state: StateManager, assessment_id: int) -> GoalProgress:
        """Check current progress towards goal."""
        pass

    @abstractmethod
    def is_complete(self, state: StateManager, assessment_id: int) -> bool:
        """Check if goal is complete."""
        pass


class AccessLevelGoal(Goal):
    """
    Goal to achieve a target access level.

    Tracks progression through:
    ANONYMOUS -> USER -> ADMIN -> ROOT
    """

    def __init__(self, target: str = 'admin'):
        """Initialize with target access level."""
        self.target = AccessLevel[target.upper()]

    @property
    def name(self) -> str:
        return 'access_level'

    def check_progress(self, state: StateManager, assessment_id: int) -> GoalProgress:
        """Check current access level progress."""
        current = state.get_highest_access(assessment_id)

        if current is None:
            current = AccessLevel.ANONYMOUS

        # Calculate percentage based on level values
        percentage = (current.value / self.target.value) * 100 if self.target.value > 0 else 100

        status = GoalStatus.NOT_STARTED
        if current.value > 0:
            status = GoalStatus.IN_PROGRESS
        if current.value >= self.target.value:
            status = GoalStatus.COMPLETED

        # Get all access records for details
        records = state.get_access_records(assessment_id)

        return GoalProgress(
            goal_name=self.name,
            status=status,
            current_value=current.name,
            target_value=self.target.name,
            percentage=min(percentage, 100),
            details={
                'access_records': len(records),
                'contexts': [r.context for r in records]
            }
        )

    def is_complete(self, state: StateManager, assessment_id: int) -> bool:
        """Check if target access level achieved."""
        current = state.get_highest_access(assessment_id)
        return current is not None and current.value >= self.target.value


class AssetAcquisitionGoal(Goal):
    """
    Goal to acquire specific types of assets.

    Targets can include:
    - database: Database dumps or access
    - source_code: Source code access
    - api_keys: API keys and secrets
    - pii: Personally identifiable information
    - credentials: User credentials
    - config: Configuration files
    """

    def __init__(self, targets: List[str] = None):
        """Initialize with target asset types."""
        if targets is None:
            targets = ['database', 'source_code', 'api_keys', 'pii']

        self.targets: Set[AssetType] = set()
        for target in targets:
            # Map string to AssetType
            type_map = {
                'database': AssetType.DATABASE,
                'source_code': AssetType.SOURCE_CODE,
                'api_keys': AssetType.API_KEY,
                'api_key': AssetType.API_KEY,
                'pii': AssetType.PII,
                'credentials': AssetType.CREDENTIALS,
                'config': AssetType.CONFIG,
            }
            if target.lower() in type_map:
                self.targets.add(type_map[target.lower()])

    @property
    def name(self) -> str:
        return 'assets'

    def check_progress(self, state: StateManager, assessment_id: int) -> GoalProgress:
        """Check asset acquisition progress."""
        acquired: Set[AssetType] = set()
        all_assets = state.get_assets(assessment_id)

        for asset in all_assets:
            if asset.type in self.targets:
                acquired.add(asset.type)

        # Calculate percentage
        percentage = (len(acquired) / len(self.targets)) * 100 if self.targets else 100

        status = GoalStatus.NOT_STARTED
        if acquired:
            status = GoalStatus.IN_PROGRESS
        if acquired >= self.targets:
            status = GoalStatus.COMPLETED
        elif acquired and percentage > 0:
            status = GoalStatus.PARTIALLY_MET

        return GoalProgress(
            goal_name=self.name,
            status=status,
            current_value=list(a.value for a in acquired),
            target_value=list(t.value for t in self.targets),
            percentage=percentage,
            details={
                'acquired': [a.value for a in acquired],
                'remaining': [t.value for t in self.targets - acquired],
                'total_assets': len(all_assets)
            }
        )

    def is_complete(self, state: StateManager, assessment_id: int) -> bool:
        """Check if all target assets acquired."""
        for target in self.targets:
            if not state.has_asset_type(assessment_id, target):
                return False
        return True


class VulnerabilityCountGoal(Goal):
    """
    Goal to discover a minimum number of vulnerabilities.

    Configurable thresholds for each severity level.
    """

    def __init__(self, critical: int = 5, high: int = 10, medium: int = 20):
        """Initialize with vulnerability count thresholds."""
        self.thresholds = {
            'critical': critical,
            'high': high,
            'medium': medium,
        }

    @property
    def name(self) -> str:
        return 'vulnerabilities'

    def check_progress(self, state: StateManager, assessment_id: int) -> GoalProgress:
        """Check vulnerability discovery progress."""
        counts = state.get_finding_counts(assessment_id)

        # Calculate weighted progress
        total_target = sum(self.thresholds.values())
        total_found = 0
        details = {}

        for severity, threshold in self.thresholds.items():
            found = counts.get(severity, 0)
            total_found += min(found, threshold)  # Cap at threshold
            details[severity] = {
                'found': found,
                'target': threshold,
                'complete': found >= threshold
            }

        percentage = (total_found / total_target) * 100 if total_target > 0 else 100

        # Determine status
        all_met = all(
            counts.get(sev, 0) >= thresh
            for sev, thresh in self.thresholds.items()
        )
        any_met = any(
            counts.get(sev, 0) >= thresh
            for sev, thresh in self.thresholds.items()
        )

        if all_met:
            status = GoalStatus.COMPLETED
        elif any_met or total_found > 0:
            status = GoalStatus.IN_PROGRESS
        else:
            status = GoalStatus.NOT_STARTED

        return GoalProgress(
            goal_name=self.name,
            status=status,
            current_value=counts,
            target_value=self.thresholds,
            percentage=percentage,
            details=details
        )

    def is_complete(self, state: StateManager, assessment_id: int) -> bool:
        """Check if vulnerability thresholds met."""
        counts = state.get_finding_counts(assessment_id)
        return all(
            counts.get(sev, 0) >= thresh
            for sev, thresh in self.thresholds.items()
        )


class FullEnumerationGoal(Goal):
    """
    Goal to achieve full enumeration coverage.

    Tracks the exploration of:
    - Endpoints discovered vs tested
    - Subdomains discovered vs tested
    - Technologies detected vs analyzed
    - Attack paths explored
    """

    def __init__(self, coverage_target: float = 0.95):
        """Initialize with coverage target (0.0 - 1.0)."""
        self.coverage_target = coverage_target
        self._discovered: Dict[str, Set[str]] = {
            'endpoints': set(),
            'subdomains': set(),
            'technologies': set(),
            'paths': set(),
        }
        self._tested: Dict[str, Set[str]] = {
            'endpoints': set(),
            'subdomains': set(),
            'technologies': set(),
            'paths': set(),
        }

    @property
    def name(self) -> str:
        return 'enumeration'

    def add_discovered(self, category: str, item: str) -> None:
        """Add a discovered item."""
        if category in self._discovered:
            self._discovered[category].add(item)

    def add_tested(self, category: str, item: str) -> None:
        """Mark an item as tested."""
        if category in self._tested:
            self._tested[category].add(item)
            # Also ensure it's in discovered
            self._discovered[category].add(item)

    def check_progress(self, state: StateManager, assessment_id: int) -> GoalProgress:
        """Check enumeration coverage progress."""
        # Get tool executions to determine tested items
        executions = state.get_tool_executions(assessment_id)

        # Update tested counts from executions
        for execution in executions:
            tool = execution.tool
            params = execution.params

            # Track endpoint testing
            if 'url' in params:
                self.add_tested('endpoints', params['url'])
            if 'targetUrl' in params:
                self.add_tested('endpoints', params['targetUrl'])

            # Track subdomain testing
            if 'subdomains' in params:
                for sub in params['subdomains']:
                    self.add_tested('subdomains', sub)

            # Track technology testing
            if 'technology' in params:
                self.add_tested('technologies', params['technology'])

        # Calculate coverage for each category
        coverages = {}
        total_discovered = 0
        total_tested = 0

        for category in self._discovered.keys():
            discovered = len(self._discovered[category])
            tested = len(self._tested[category])
            total_discovered += discovered
            total_tested += tested

            if discovered > 0:
                coverages[category] = {
                    'discovered': discovered,
                    'tested': tested,
                    'coverage': tested / discovered
                }
            else:
                coverages[category] = {
                    'discovered': 0,
                    'tested': 0,
                    'coverage': 1.0  # Nothing to test = 100% coverage
                }

        # Overall coverage
        overall_coverage = total_tested / total_discovered if total_discovered > 0 else 1.0
        percentage = (overall_coverage / self.coverage_target) * 100

        # Determine status
        if overall_coverage >= self.coverage_target:
            status = GoalStatus.COMPLETED
        elif overall_coverage > 0:
            status = GoalStatus.IN_PROGRESS
        else:
            status = GoalStatus.NOT_STARTED

        return GoalProgress(
            goal_name=self.name,
            status=status,
            current_value=overall_coverage,
            target_value=self.coverage_target,
            percentage=min(percentage, 100),
            details=coverages
        )

    def is_complete(self, state: StateManager, assessment_id: int) -> bool:
        """Check if coverage target met."""
        progress = self.check_progress(state, assessment_id)
        return progress.current_value >= self.coverage_target


@dataclass
class GoalSet:
    """Collection of goals to track."""
    goals: Dict[str, Goal] = field(default_factory=dict)

    def __post_init__(self):
        """Initialize default goals if empty."""
        if not self.goals:
            self.goals = {
                'access_level': AccessLevelGoal(target='admin'),
                'assets': AssetAcquisitionGoal(),
                'vulnerabilities': VulnerabilityCountGoal(),
                'enumeration': FullEnumerationGoal(),
            }


class GoalTracker:
    """
    Track ALL goals simultaneously.

    Goals:
    - Access Level Gates (anon -> user -> admin -> root)
    - Asset Acquisition (db dump, source code, API keys, PII)
    - Vulnerability Count (critical, high, medium thresholds)
    - Full Enumeration (exhaust all paths)
    """

    def __init__(self, state_manager: StateManager, config: Dict[str, Any] = None):
        """Initialize goal tracker."""
        self.state = state_manager
        self.config = config or {}
        self.goals = self._init_goals()

    def _init_goals(self) -> GoalSet:
        """Initialize goals from config."""
        goal_config = self.config.get('goals', {})

        goals = {}

        # Access level goal
        if goal_config.get('access_level', {}).get('enabled', True):
            target = goal_config.get('access_level', {}).get('target', 'admin')
            goals['access_level'] = AccessLevelGoal(target=target)

        # Asset acquisition goal
        if goal_config.get('assets', {}).get('enabled', True):
            targets = goal_config.get('assets', {}).get('targets', [
                'database', 'source_code', 'api_keys', 'pii'
            ])
            goals['assets'] = AssetAcquisitionGoal(targets=targets)

        # Vulnerability count goal
        if goal_config.get('vulnerabilities', {}).get('enabled', True):
            thresholds = goal_config.get('vulnerabilities', {}).get('thresholds', {})
            goals['vulnerabilities'] = VulnerabilityCountGoal(
                critical=thresholds.get('critical', 5),
                high=thresholds.get('high', 10),
                medium=thresholds.get('medium', 20)
            )

        # Enumeration goal
        if goal_config.get('enumeration', {}).get('enabled', True):
            coverage = goal_config.get('enumeration', {}).get('coverage_target', 0.95)
            goals['enumeration'] = FullEnumerationGoal(coverage_target=coverage)

        return GoalSet(goals=goals)

    def check_completion(self, assessment_id: int) -> Dict[str, GoalProgress]:
        """
        Check status for ALL goals.

        Assessment is complete when all enabled goals are met.
        """
        progress = {}
        for name, goal in self.goals.goals.items():
            progress[name] = goal.check_progress(self.state, assessment_id)
        return progress

    def is_assessment_complete(self, assessment_id: int) -> bool:
        """Check if all goals are met."""
        for goal in self.goals.goals.values():
            if not goal.is_complete(self.state, assessment_id):
                return False
        return True

    def get_summary(self, assessment_id: int) -> Dict[str, Any]:
        """Get summary of goal progress."""
        progress = self.check_completion(assessment_id)

        completed = sum(1 for p in progress.values() if p.status == GoalStatus.COMPLETED)
        total = len(progress)

        overall_percentage = sum(p.percentage for p in progress.values()) / total if total > 0 else 0

        return {
            'overall_complete': completed == total,
            'completed_goals': completed,
            'total_goals': total,
            'overall_percentage': overall_percentage,
            'goal_status': {
                name: {
                    'status': p.status.value,
                    'percentage': p.percentage,
                    'current': p.current_value,
                    'target': p.target_value,
                }
                for name, p in progress.items()
            }
        }

    def get_remaining_goals(self, assessment_id: int) -> List[str]:
        """Get list of goals not yet complete."""
        remaining = []
        for name, goal in self.goals.goals.items():
            if not goal.is_complete(self.state, assessment_id):
                remaining.append(name)
        return remaining

    def get_priority_goal(self, assessment_id: int) -> Optional[str]:
        """
        Get the highest priority incomplete goal.

        Priority order:
        1. Access level (required for other goals)
        2. Vulnerabilities (quick wins)
        3. Assets (valuable data)
        4. Enumeration (completeness)
        """
        priority_order = ['access_level', 'vulnerabilities', 'assets', 'enumeration']

        for goal_name in priority_order:
            if goal_name in self.goals.goals:
                if not self.goals.goals[goal_name].is_complete(self.state, assessment_id):
                    return goal_name

        return None

    def add_discovered_item(self, category: str, item: str) -> None:
        """Add discovered item for enumeration tracking."""
        if 'enumeration' in self.goals.goals:
            enum_goal = self.goals.goals['enumeration']
            if isinstance(enum_goal, FullEnumerationGoal):
                enum_goal.add_discovered(category, item)

    def add_tested_item(self, category: str, item: str) -> None:
        """Add tested item for enumeration tracking."""
        if 'enumeration' in self.goals.goals:
            enum_goal = self.goals.goals['enumeration']
            if isinstance(enum_goal, FullEnumerationGoal):
                enum_goal.add_tested(category, item)

    def export_goals_state(self) -> Dict[str, Any]:
        """Export goals state for persistence."""
        if 'enumeration' in self.goals.goals:
            enum_goal = self.goals.goals['enumeration']
            if isinstance(enum_goal, FullEnumerationGoal):
                return {
                    'discovered': {k: list(v) for k, v in enum_goal._discovered.items()},
                    'tested': {k: list(v) for k, v in enum_goal._tested.items()},
                }
        return {}

    def import_goals_state(self, state_data: Dict[str, Any]) -> None:
        """Import goals state from persistence."""
        if 'enumeration' in self.goals.goals:
            enum_goal = self.goals.goals['enumeration']
            if isinstance(enum_goal, FullEnumerationGoal):
                discovered = state_data.get('discovered', {})
                tested = state_data.get('tested', {})

                for category, items in discovered.items():
                    for item in items:
                        enum_goal.add_discovered(category, item)

                for category, items in tested.items():
                    for item in items:
                        enum_goal.add_tested(category, item)
