"""
Real-Time Intelligence Fetcher for DeadMan Pen.

Integrates with security intelligence sources during assessment:
- NVD (CVE search for detected technologies)
- Exploit-DB (PoC for discovered vulns)
- GitHub Advisory (package vulnerabilities)
- MITRE ATT&CK (technique mapping)
- Nuclei Templates (available detections)
"""

import asyncio
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional
from datetime import datetime, timedelta
from functools import lru_cache

from .mcp_bridge import MCPToolBridge


@dataclass
class CVEInfo:
    """CVE information from NVD."""
    id: str
    description: str
    cvss_score: Optional[float] = None
    cvss_vector: Optional[str] = None
    published: Optional[str] = None
    modified: Optional[str] = None
    references: List[str] = field(default_factory=list)
    cwe_ids: List[str] = field(default_factory=list)
    affected_products: List[str] = field(default_factory=list)


@dataclass
class ExploitInfo:
    """Exploit information from Exploit-DB."""
    id: str
    title: str
    exploit_type: str
    platform: str
    verified: bool = False
    url: Optional[str] = None
    author: Optional[str] = None
    date: Optional[str] = None


@dataclass
class MITRETechnique:
    """MITRE ATT&CK technique."""
    id: str
    name: str
    tactic: str
    description: str
    platforms: List[str] = field(default_factory=list)
    detection: Optional[str] = None
    mitigation: Optional[str] = None


@dataclass
class TechContext:
    """Vulnerability context for a technology."""
    technology: str
    version: Optional[str]
    cves: List[CVEInfo] = field(default_factory=list)
    exploits: List[ExploitInfo] = field(default_factory=list)
    techniques: List[MITRETechnique] = field(default_factory=list)
    nuclei_templates: List[str] = field(default_factory=list)
    risk_score: float = 0.0


@dataclass
class EnrichedFinding:
    """Finding enriched with intelligence data."""
    original_finding: Dict[str, Any]
    cves: List[CVEInfo] = field(default_factory=list)
    exploits: List[ExploitInfo] = field(default_factory=list)
    mitre_techniques: List[MITRETechnique] = field(default_factory=list)
    nuclei_templates: List[str] = field(default_factory=list)
    risk_score: float = 0.0
    remediation: Optional[str] = None


class IntelCache:
    """Simple cache for intel data."""

    def __init__(self, ttl_seconds: int = 3600):
        self.ttl = ttl_seconds
        self._cache: Dict[str, tuple] = {}  # key -> (data, timestamp)

    def get(self, key: str) -> Optional[Any]:
        if key in self._cache:
            data, timestamp = self._cache[key]
            if datetime.now() - timestamp < timedelta(seconds=self.ttl):
                return data
            del self._cache[key]
        return None

    def set(self, key: str, value: Any) -> None:
        self._cache[key] = (value, datetime.now())

    def clear(self) -> None:
        self._cache.clear()


class IntelFetcher:
    """
    Real-time intelligence gathering during assessment.

    Sources (queried automatically):
    - NVD (CVE search for detected technologies)
    - Exploit-DB (PoC for discovered vulns)
    - GitHub Advisory (package vulnerabilities)
    - MITRE ATT&CK (technique mapping)
    - Nuclei Templates (available detections)
    """

    def __init__(self, tool_bridge: MCPToolBridge):
        """Initialize intel fetcher."""
        self.tools = tool_bridge
        self._cache = IntelCache(ttl_seconds=3600)

    async def enrich_finding(self, finding: Dict[str, Any]) -> EnrichedFinding:
        """
        Enrich a finding with intelligence data.

        When vulnerability discovered:
        1. Search NVD for CVE matches
        2. Search Exploit-DB for PoC
        3. Check Nuclei for detection templates
        4. Map to MITRE ATT&CK techniques
        5. Return enriched finding with context
        """
        enriched = EnrichedFinding(original_finding=finding)

        # Extract keywords from finding
        keywords = self._extract_keywords(finding)

        # Search in parallel
        tasks = []

        # CVE search
        for keyword in keywords[:3]:  # Limit to 3 keywords
            tasks.append(self._search_cves(keyword))

        # Exploit search
        for keyword in keywords[:2]:
            tasks.append(self._search_exploits(keyword))

        # MITRE mapping
        if finding.get('type') or finding.get('title'):
            tasks.append(self._map_to_mitre(finding))

        # Execute searches
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Process results
        for result in results:
            if isinstance(result, Exception):
                continue

            if isinstance(result, list):
                for item in result:
                    if isinstance(item, CVEInfo):
                        enriched.cves.append(item)
                    elif isinstance(item, ExploitInfo):
                        enriched.exploits.append(item)
                    elif isinstance(item, MITRETechnique):
                        enriched.mitre_techniques.append(item)

        # Calculate risk score
        enriched.risk_score = self._calculate_risk_score(enriched)

        # Generate remediation
        enriched.remediation = self._generate_remediation(enriched)

        return enriched

    async def get_tech_context(self, tech: str, version: Optional[str] = None) -> TechContext:
        """
        Get vulnerability context for a technology.

        When technology detected:
        1. Query intel_tech_vulns for known issues
        2. Get relevant CVEs
        3. Identify common attack patterns
        4. Return context for rule evaluation
        """
        cache_key = f"tech:{tech}:{version or 'any'}"
        cached = self._cache.get(cache_key)
        if cached:
            return cached

        context = TechContext(technology=tech, version=version)

        # Get tech-specific vulnerabilities
        result = await self.tools.run_intel_tech(tech, version)
        if result.success:
            data = result.data

            # Extract CVEs
            for cve_data in data.get('cves', []):
                context.cves.append(CVEInfo(
                    id=cve_data.get('id', ''),
                    description=cve_data.get('description', ''),
                    cvss_score=cve_data.get('cvss'),
                    published=cve_data.get('published'),
                    references=cve_data.get('references', [])
                ))

            # Extract techniques
            for technique_data in data.get('techniques', []):
                context.techniques.append(MITRETechnique(
                    id=technique_data.get('id', ''),
                    name=technique_data.get('name', ''),
                    tactic=technique_data.get('tactic', ''),
                    description=technique_data.get('description', ''),
                    platforms=technique_data.get('platforms', [])
                ))

            # Get nuclei templates
            context.nuclei_templates = data.get('nuclei_templates', [])

        # Calculate risk score
        context.risk_score = self._calculate_tech_risk(context)

        self._cache.set(cache_key, context)
        return context

    async def search_comprehensive(self, query: str) -> Dict[str, Any]:
        """Search across all intelligence sources."""
        cache_key = f"comprehensive:{query}"
        cached = self._cache.get(cache_key)
        if cached:
            return cached

        result = await self.tools.run_intel(query)
        if result.success:
            self._cache.set(cache_key, result.data)
            return result.data

        return {}

    async def _search_cves(self, keyword: str) -> List[CVEInfo]:
        """Search CVEs for a keyword."""
        cache_key = f"cve:{keyword}"
        cached = self._cache.get(cache_key)
        if cached:
            return cached

        cves = []
        result = await self.tools.run_intel_cve(keyword, cvss_min=0.0, limit=10)

        if result.success:
            for cve_data in result.data.get('cves', []):
                cves.append(CVEInfo(
                    id=cve_data.get('id', ''),
                    description=cve_data.get('description', ''),
                    cvss_score=cve_data.get('cvss'),
                    cvss_vector=cve_data.get('cvss_vector'),
                    published=cve_data.get('published'),
                    modified=cve_data.get('modified'),
                    references=cve_data.get('references', []),
                    cwe_ids=cve_data.get('cwe_ids', []),
                    affected_products=cve_data.get('affected_products', [])
                ))

        self._cache.set(cache_key, cves)
        return cves

    async def _search_exploits(self, keyword: str) -> List[ExploitInfo]:
        """Search Exploit-DB for exploits."""
        cache_key = f"exploit:{keyword}"
        cached = self._cache.get(cache_key)
        if cached:
            return cached

        exploits = []
        result = await self.tools.execute('intel_exploit_search', {'query': keyword})

        if result.success:
            for exploit_data in result.data.get('exploits', []):
                exploits.append(ExploitInfo(
                    id=exploit_data.get('id', ''),
                    title=exploit_data.get('title', ''),
                    exploit_type=exploit_data.get('type', ''),
                    platform=exploit_data.get('platform', ''),
                    verified=exploit_data.get('verified', False),
                    url=exploit_data.get('url'),
                    author=exploit_data.get('author'),
                    date=exploit_data.get('date')
                ))

        self._cache.set(cache_key, exploits)
        return exploits

    async def _map_to_mitre(self, finding: Dict[str, Any]) -> List[MITRETechnique]:
        """Map finding to MITRE ATT&CK techniques."""
        techniques = []

        # Extract relevant info from finding
        finding_type = finding.get('type', '')
        finding_title = finding.get('title', '')
        finding_tool = finding.get('tool', '')

        # Map common finding types to tactics
        tactic_mapping = {
            'prompt_injection': 'initial-access',
            'ssrf': 'initial-access',
            'rce': 'execution',
            'command_injection': 'execution',
            'jwt': 'credential-access',
            'oauth': 'credential-access',
            'idor': 'privilege-escalation',
            'escalation': 'privilege-escalation',
            'exfiltration': 'exfiltration',
            'data_leak': 'exfiltration',
        }

        # Find matching tactic
        tactic = None
        for keyword, mapped_tactic in tactic_mapping.items():
            if keyword in finding_type.lower() or keyword in finding_title.lower() or keyword in finding_tool.lower():
                tactic = mapped_tactic
                break

        if tactic:
            result = await self.tools.execute('intel_mitre_attack', {'tactic': tactic})
            if result.success:
                for tech_data in result.data.get('techniques', [])[:5]:
                    techniques.append(MITRETechnique(
                        id=tech_data.get('id', ''),
                        name=tech_data.get('name', ''),
                        tactic=tactic,
                        description=tech_data.get('description', ''),
                        platforms=tech_data.get('platforms', []),
                        detection=tech_data.get('detection'),
                        mitigation=tech_data.get('mitigation')
                    ))

        return techniques

    def _extract_keywords(self, finding: Dict[str, Any]) -> List[str]:
        """Extract searchable keywords from a finding."""
        keywords = []

        # Add title words
        title = finding.get('title', '')
        keywords.extend(title.lower().split())

        # Add tool name
        tool = finding.get('tool', '')
        if tool:
            keywords.append(tool.lower())

        # Add type
        finding_type = finding.get('type', '')
        if finding_type:
            keywords.append(finding_type.lower())

        # Extract from evidence
        evidence = finding.get('evidence', {})
        if isinstance(evidence, dict):
            for key, value in evidence.items():
                if isinstance(value, str) and len(value) < 50:
                    keywords.append(value.lower())

        # Deduplicate and filter
        keywords = list(set(keywords))
        keywords = [k for k in keywords if len(k) > 2 and not k.isdigit()]

        return keywords[:5]

    def _calculate_risk_score(self, enriched: EnrichedFinding) -> float:
        """Calculate risk score for an enriched finding."""
        score = 0.0

        # Base score from original finding severity
        severity = enriched.original_finding.get('severity', 'info')
        severity_scores = {
            'critical': 10.0,
            'high': 7.5,
            'medium': 5.0,
            'low': 2.5,
            'info': 0.5
        }
        score += severity_scores.get(severity, 1.0)

        # Add for CVEs
        for cve in enriched.cves:
            if cve.cvss_score:
                score += cve.cvss_score * 0.5

        # Add for exploits (especially verified ones)
        for exploit in enriched.exploits:
            score += 2.0
            if exploit.verified:
                score += 3.0

        # Cap at 10
        return min(score, 10.0)

    def _calculate_tech_risk(self, context: TechContext) -> float:
        """Calculate risk score for a technology context."""
        score = 0.0

        # CVE count and severity
        for cve in context.cves:
            if cve.cvss_score:
                score += cve.cvss_score * 0.3

        # Exploit availability
        for exploit in context.exploits:
            score += 1.5
            if exploit.verified:
                score += 2.5

        # Nuclei templates indicate known detection
        score += len(context.nuclei_templates) * 0.5

        return min(score, 10.0)

    def _generate_remediation(self, enriched: EnrichedFinding) -> str:
        """Generate remediation advice based on intel."""
        remediations = []

        # From MITRE techniques
        for technique in enriched.mitre_techniques:
            if technique.mitigation:
                remediations.append(f"- {technique.mitigation}")

        # From CVEs
        for cve in enriched.cves:
            if cve.references:
                remediations.append(f"- See {cve.id}: {cve.references[0]}")

        # Generic based on finding type
        finding_type = enriched.original_finding.get('type', '').lower()
        generic_remediations = {
            'prompt_injection': '- Implement input validation and sanitization for AI prompts',
            'ssrf': '- Validate and whitelist allowed URLs; block internal IP ranges',
            'jwt': '- Use strong signing algorithms; validate all claims; implement token rotation',
            'cors': '- Configure strict CORS policies; avoid wildcard origins',
            'idor': '- Implement proper authorization checks; use indirect object references',
        }

        for key, remediation in generic_remediations.items():
            if key in finding_type or key in enriched.original_finding.get('title', '').lower():
                remediations.append(remediation)

        return '\n'.join(remediations[:5]) if remediations else 'No specific remediation available'

    async def get_nuclei_templates(self, vulnerability_type: str) -> List[str]:
        """Get relevant Nuclei templates for a vulnerability type."""
        result = await self.tools.execute('intel_nuclei_templates', {'query': vulnerability_type})
        if result.success:
            return result.data.get('templates', [])
        return []

    async def check_exploit_available(self, cve_id: str) -> bool:
        """Check if a public exploit exists for a CVE."""
        exploits = await self._search_exploits(cve_id)
        return len(exploits) > 0
