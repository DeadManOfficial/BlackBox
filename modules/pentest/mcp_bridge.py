"""
MCP Tool Bridge for DeadMan Pen.

Executes MCP tools from Python orchestrator, providing unified
interface to all 116 security scanners from deadman-toolkit.

RULEBOOK: ~/BlackBox/docs/BOUNTY_RULEBOOK.md
  - Continuous flow, no halts
  - All tools mandatory, parallelized

Token Optimization (T0-T4):
  T0: ToolSearch before MCP calls (handled by caller)
  T1: Response truncation for large outputs
  T2: Checkpoint support for multi-phase operations
  T3: File storage for data, summary for context
  T4: Batch processing with size limits
"""

import asyncio
import json
import subprocess
import time
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Callable
from pathlib import Path
from enum import Enum

# Token optimization imports
try:
    from modules.utils.response_handler import ResponseHandler, truncate
    from modules.utils.token_rules import TokenRules, SCRAPING_RULES
    TOKEN_OPTIMIZATION_AVAILABLE = True
except ImportError:
    TOKEN_OPTIMIZATION_AVAILABLE = False


class ToolCategory(Enum):
    """Categories of security tools."""
    RECON = 'recon'
    SCANNING = 'scanning'
    EXPLOITATION = 'exploitation'
    POST_EXPLOITATION = 'post_exploitation'
    INTEL = 'intel'
    AI_SECURITY = 'ai_security'
    WEB_SECURITY = 'web_security'
    ADVANCED = 'advanced'


@dataclass
class ToolMetadata:
    """Metadata for an MCP tool."""
    name: str
    category: ToolCategory
    description: str
    parameters: Dict[str, Any]
    output_schema: Dict[str, Any] = field(default_factory=dict)
    rate_limit: Optional[int] = None  # requests per minute
    timeout: int = 60000  # milliseconds


@dataclass
class ToolResult:
    """Result from MCP tool execution."""
    tool: str
    success: bool
    data: Dict[str, Any]
    error: Optional[str] = None
    duration_ms: int = 0
    raw_output: Optional[str] = None
    was_truncated: bool = False  # T1: Track if response was truncated
    saved_path: Optional[str] = None  # T3: Path if saved to file


# Tool registry with metadata
TOOL_REGISTRY: Dict[str, ToolMetadata] = {
    # Intel Tools
    'intel_cve_search': ToolMetadata(
        name='intel_cve_search',
        category=ToolCategory.INTEL,
        description='Search CVEs in NVD database',
        parameters={'keyword': str, 'cvssMin': float, 'limit': int}
    ),
    'intel_exploit_search': ToolMetadata(
        name='intel_exploit_search',
        category=ToolCategory.INTEL,
        description='Search Exploit-DB for exploits and PoC',
        parameters={'query': str, 'platform': str}
    ),
    'intel_github_advisory': ToolMetadata(
        name='intel_github_advisory',
        category=ToolCategory.INTEL,
        description='Search GitHub Security Advisories',
        parameters={'ecosystem': str, 'package': str}
    ),
    'intel_nuclei_templates': ToolMetadata(
        name='intel_nuclei_templates',
        category=ToolCategory.INTEL,
        description='Search Nuclei detection templates',
        parameters={'query': str}
    ),
    'intel_mitre_attack': ToolMetadata(
        name='intel_mitre_attack',
        category=ToolCategory.INTEL,
        description='Search MITRE ATT&CK techniques',
        parameters={'tactic': str, 'platform': str}
    ),
    'intel_comprehensive': ToolMetadata(
        name='intel_comprehensive',
        category=ToolCategory.INTEL,
        description='Search across all intelligence sources',
        parameters={'query': str}
    ),
    'intel_tech_vulns': ToolMetadata(
        name='intel_tech_vulns',
        category=ToolCategory.INTEL,
        description='Get vulnerability context for a technology',
        parameters={'technology': str, 'version': str}
    ),

    # Scanning Tools
    'nuclei_scan': ToolMetadata(
        name='nuclei_scan',
        category=ToolCategory.SCANNING,
        description='Run Nuclei vulnerability scanner',
        parameters={'target': str, 'severity': list, 'templates': list},
        timeout=300000
    ),
    'js_analyze': ToolMetadata(
        name='js_analyze',
        category=ToolCategory.SCANNING,
        description='Analyze JavaScript for secrets and endpoints',
        parameters={'url': str}
    ),
    'js_analyze_batch': ToolMetadata(
        name='js_analyze_batch',
        category=ToolCategory.SCANNING,
        description='Batch analyze multiple JavaScript files',
        parameters={'urls': list}
    ),

    # AI Security Tools
    'ai_security_test': ToolMetadata(
        name='ai_security_test',
        category=ToolCategory.AI_SECURITY,
        description='Test AI endpoint for vulnerabilities',
        parameters={'url': str, 'categories': list}
    ),
    'llm_redteam_scan': ToolMetadata(
        name='llm_redteam_scan',
        category=ToolCategory.AI_SECURITY,
        description='Comprehensive LLM security assessment',
        parameters={'targetUrl': str, 'strategies': list, 'vulnerabilities': list},
        timeout=180000
    ),
    'indirect_injection_test': ToolMetadata(
        name='indirect_injection_test',
        category=ToolCategory.AI_SECURITY,
        description='Test for indirect prompt injection',
        parameters={'targetUrl': str, 'method': str}
    ),
    'crescendo_attack': ToolMetadata(
        name='crescendo_attack',
        category=ToolCategory.AI_SECURITY,
        description='Multi-turn escalation attack on AI systems',
        parameters={'targetUrl': str, 'goal': str, 'maxTurns': int},
        timeout=300000
    ),

    # Web Security Tools
    'cors_scan': ToolMetadata(
        name='cors_scan',
        category=ToolCategory.WEB_SECURITY,
        description='Test for CORS misconfigurations',
        parameters={'targetUrl': str, 'testNullOrigin': bool, 'testSubdomain': bool}
    ),
    'ssrf_scan': ToolMetadata(
        name='ssrf_scan',
        category=ToolCategory.WEB_SECURITY,
        description='Test for Server-Side Request Forgery',
        parameters={'targetUrl': str, 'param': str, 'clouds': list}
    ),
    'graphql_scan': ToolMetadata(
        name='graphql_scan',
        category=ToolCategory.WEB_SECURITY,
        description='GraphQL security testing',
        parameters={'graphqlUrl': str, 'testIntrospection': bool, 'testBatching': bool}
    ),
    'xxe_scan': ToolMetadata(
        name='xxe_scan',
        category=ToolCategory.WEB_SECURITY,
        description='XML External Entity injection testing',
        parameters={'targetUrl': str, 'testFileRead': bool, 'testSSRF': bool}
    ),
    'ssti_scan': ToolMetadata(
        name='ssti_scan',
        category=ToolCategory.WEB_SECURITY,
        description='Server-Side Template Injection testing',
        parameters={'targetUrl': str, 'param': str, 'engines': list}
    ),
    'command_injection_scan': ToolMetadata(
        name='command_injection_scan',
        category=ToolCategory.WEB_SECURITY,
        description='OS command injection testing',
        parameters={'targetUrl': str, 'param': str, 'testTimeBased': bool}
    ),
    'path_traversal_scan': ToolMetadata(
        name='path_traversal_scan',
        category=ToolCategory.WEB_SECURITY,
        description='Path traversal / LFI testing',
        parameters={'targetUrl': str, 'param': str, 'testPhpWrappers': bool, 'depth': int}
    ),

    # Advanced Attack Tools
    'waf_bypass_scan': ToolMetadata(
        name='waf_bypass_scan',
        category=ToolCategory.ADVANCED,
        description='Discover origin IP behind WAF/CDN',
        parameters={'domain': str}
    ),
    'race_condition_scan': ToolMetadata(
        name='race_condition_scan',
        category=ToolCategory.ADVANCED,
        description='Test for race conditions',
        parameters={'url': str, 'payload': dict}
    ),
    'oauth_scan': ToolMetadata(
        name='oauth_scan',
        category=ToolCategory.ADVANCED,
        description='OAuth security testing',
        parameters={'authUrl': str, 'categories': list}
    ),
    'jwt_analyze': ToolMetadata(
        name='jwt_analyze',
        category=ToolCategory.ADVANCED,
        description='JWT security analysis',
        parameters={'token': str, 'testNoneAlg': bool, 'testAlgConfusion': bool}
    ),
    'idor_scan': ToolMetadata(
        name='idor_scan',
        category=ToolCategory.ADVANCED,
        description='Insecure Direct Object Reference testing',
        parameters={'url': str, 'param': str, 'testType': str}
    ),
    'http_smuggling_scan': ToolMetadata(
        name='http_smuggling_scan',
        category=ToolCategory.ADVANCED,
        description='HTTP request smuggling testing',
        parameters={'targetUrl': str, 'testClTe': bool, 'testTeCl': bool}
    ),
    'cache_poisoning_scan': ToolMetadata(
        name='cache_poisoning_scan',
        category=ToolCategory.ADVANCED,
        description='Web cache poisoning testing',
        parameters={'targetUrl': str, 'testUnkeyedHeaders': bool, 'testFatGet': bool}
    ),
    'websocket_scan': ToolMetadata(
        name='websocket_scan',
        category=ToolCategory.WEB_SECURITY,
        description='WebSocket security testing',
        parameters={'websocketUrl': str, 'testCswsh': bool, 'testInjection': bool}
    ),

    # Backend Access Tools
    'backend_access_scan': ToolMetadata(
        name='backend_access_scan',
        category=ToolCategory.EXPLOITATION,
        description='Test Supabase/Firebase direct API access',
        parameters={'service': str, 'url': str, 'anon_key': str, 'project_id': str}
    ),
    'cloud_storage_enum': ToolMetadata(
        name='cloud_storage_enum',
        category=ToolCategory.RECON,
        description='Enumerate cloud storage buckets',
        parameters={'provider': str, 'url': str}
    ),

    # Payment Security Tools
    'payment_security_test': ToolMetadata(
        name='payment_security_test',
        category=ToolCategory.EXPLOITATION,
        description='Test payment endpoint security',
        parameters={'url': str, 'categories': list}
    ),
    'payment_injection_scan': ToolMetadata(
        name='payment_injection_scan',
        category=ToolCategory.EXPLOITATION,
        description='Test Stripe checkout for parameter injection',
        parameters={'url': str, 'base_payload': dict}
    ),
    'payment_webhook_test': ToolMetadata(
        name='payment_webhook_test',
        category=ToolCategory.EXPLOITATION,
        description='Test webhook signature validation',
        parameters={'url': str}
    ),

    # Database Tools
    'db_error_exploit': ToolMetadata(
        name='db_error_exploit',
        category=ToolCategory.EXPLOITATION,
        description='Extract database info via error messages',
        parameters={'url': str, 'param': str, 'dbType': str}
    ),

    # API Tools
    'api_enumerate': ToolMetadata(
        name='api_enumerate',
        category=ToolCategory.RECON,
        description='API endpoint discovery',
        parameters={'baseUrl': str, 'wordlist': str, 'detectVersions': bool}
    ),

    # Auth Tools
    'auth_flow_attack': ToolMetadata(
        name='auth_flow_attack',
        category=ToolCategory.EXPLOITATION,
        description='Test authentication weaknesses',
        parameters={'url': str, 'attackType': str}
    ),
    'cors_auth_scan': ToolMetadata(
        name='cors_auth_scan',
        category=ToolCategory.WEB_SECURITY,
        description='CORS + auth token exploitation',
        parameters={'url': str, 'auth_token': str}
    ),

    # Autonomous Tools
    'pentest_run': ToolMetadata(
        name='pentest_run',
        category=ToolCategory.EXPLOITATION,
        description='Run autonomous penetration test',
        parameters={'target': str, 'phases': list},
        timeout=600000
    ),
    'pentest_attack_path': ToolMetadata(
        name='pentest_attack_path',
        category=ToolCategory.EXPLOITATION,
        description='Plan optimal attack path',
        parameters={'initialState': dict, 'goalState': dict}
    ),

    # Stealth Tools
    'stealth_fetch': ToolMetadata(
        name='stealth_fetch',
        category=ToolCategory.RECON,
        description='Fetch URL with anti-detect browser',
        parameters={'url': str, 'engine': str}
    ),
    'stealth_session': ToolMetadata(
        name='stealth_session',
        category=ToolCategory.RECON,
        description='Run stealth session with rotation',
        parameters={'urls': list, 'rotateEvery': int}
    ),

    # Subdomain/CRLF Tools
    'subdomain_takeover_scan': ToolMetadata(
        name='subdomain_takeover_scan',
        category=ToolCategory.RECON,
        description='Subdomain takeover detection',
        parameters={'subdomains': list, 'services': list}
    ),
    'crlf_scan': ToolMetadata(
        name='crlf_scan',
        category=ToolCategory.WEB_SECURITY,
        description='CRLF injection testing',
        parameters={'targetUrl': str, 'testResponseSplitting': bool}
    ),
    'host_header_scan': ToolMetadata(
        name='host_header_scan',
        category=ToolCategory.WEB_SECURITY,
        description='Host header injection testing',
        parameters={'targetUrl': str, 'testPasswordReset': bool}
    ),

    # Hybrid Planner
    'hybrid_plan_attack': ToolMetadata(
        name='hybrid_plan_attack',
        category=ToolCategory.EXPLOITATION,
        description='Plan attack path using MCTS + RRT* + A*',
        parameters={'goalState': dict, 'initialState': dict, 'mctsIterations': int}
    ),
}


class MCPToolBridge:
    """
    Bridge to execute MCP tools from Python orchestrator.

    Wraps all 59+ security scanners from deadman-toolkit with:
    - Parameter validation
    - Timeout management
    - Error handling
    - Result normalization
    - Token optimization (T0-T4)
    """

    # T1: Response size thresholds
    MAX_RESPONSE_CHARS = 10000
    TRUNCATE_HEAD_RATIO = 0.6
    TRUNCATE_TAIL_RATIO = 0.4

    # T4: Batch size limit
    BATCH_SIZE = 10

    def __init__(self, mcp_server_path: str = "G:/.claude-home/mcp-server",
                 target: str = None):
        """Initialize the MCP tool bridge."""
        self.mcp_server_path = Path(mcp_server_path)
        self.scanner_bridge_path = Path("G:/.claude-home/security-scanner/scanner-bridge.js")
        self._tool_cache: Dict[str, ToolMetadata] = TOOL_REGISTRY.copy()
        self.target = target  # For checkpointing (T2)

        # Initialize token rules if available
        if TOKEN_OPTIMIZATION_AVAILABLE and target:
            self._token_rules = TokenRules(target)
        else:
            self._token_rules = None

    def get_tool_metadata(self, tool: str) -> Optional[ToolMetadata]:
        """Get tool capabilities, parameters, output schema."""
        return self._tool_cache.get(tool)

    def list_tools(self, category: Optional[ToolCategory] = None) -> List[str]:
        """List available tools, optionally filtered by category."""
        if category:
            return [name for name, meta in self._tool_cache.items()
                    if meta.category == category]
        return list(self._tool_cache.keys())

    async def execute(self, tool: str, params: Dict[str, Any],
                      timeout: Optional[int] = None) -> ToolResult:
        """
        Execute MCP tool and return normalized result.

        Args:
            tool: Tool name to execute
            params: Parameters for the tool
            timeout: Optional timeout override in milliseconds

        Returns:
            ToolResult with normalized output
        """
        metadata = self.get_tool_metadata(tool)
        if not metadata:
            return ToolResult(
                tool=tool,
                success=False,
                data={},
                error=f"Unknown tool: {tool}"
            )

        effective_timeout = timeout or metadata.timeout

        start_time = time.time()

        try:
            # Execute via scanner bridge
            result = await self._execute_via_bridge(tool, params, effective_timeout)
            duration_ms = int((time.time() - start_time) * 1000)

            # T1: Apply truncation if response is too large
            was_truncated = False
            saved_path = None

            if TOKEN_OPTIMIZATION_AVAILABLE and self._token_rules:
                result_str = json.dumps(result, default=str)
                if len(result_str) > self.MAX_RESPONSE_CHARS:
                    # T3: Save full data to file
                    saved_path = self._token_rules.save_to_file(
                        result, f"{tool}_{int(time.time())}.json"
                    )
                    # T1: Get summary for context
                    result = {
                        "summary": self._token_rules.get_summary(result),
                        "saved_to": saved_path,
                        "original_size": len(result_str),
                        "truncated": True
                    }
                    was_truncated = True

            return ToolResult(
                tool=tool,
                success=True,
                data=result,
                duration_ms=duration_ms,
                was_truncated=was_truncated,
                saved_path=saved_path
            )

        except asyncio.TimeoutError:
            duration_ms = int((time.time() - start_time) * 1000)
            return ToolResult(
                tool=tool,
                success=False,
                data={},
                error=f"Tool execution timed out after {effective_timeout}ms",
                duration_ms=duration_ms
            )

        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            return ToolResult(
                tool=tool,
                success=False,
                data={},
                error=str(e),
                duration_ms=duration_ms
            )

    async def _execute_via_bridge(self, tool: str, params: Dict[str, Any],
                                   timeout: int) -> Dict[str, Any]:
        """Execute tool via the scanner bridge."""
        # Prepare the command
        cmd_input = json.dumps({
            'tool': tool,
            'params': params
        })

        # Run the scanner bridge
        process = await asyncio.create_subprocess_exec(
            'node',
            str(self.scanner_bridge_path),
            '--execute',
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=str(self.scanner_bridge_path.parent)
        )

        try:
            stdout, stderr = await asyncio.wait_for(
                process.communicate(input=cmd_input.encode()),
                timeout=timeout / 1000
            )

            if process.returncode != 0:
                error_msg = stderr.decode() if stderr else "Unknown error"
                raise RuntimeError(f"Tool execution failed: {error_msg}")

            return json.loads(stdout.decode())

        except asyncio.TimeoutError:
            process.kill()
            raise

    async def execute_batch(self, tasks: List[Dict[str, Any]],
                            max_concurrent: int = 5) -> List[ToolResult]:
        """
        Execute multiple tools concurrently with T4 batch limits.

        Args:
            tasks: List of {'tool': str, 'params': dict} dicts
            max_concurrent: Maximum concurrent executions

        Returns:
            List of ToolResults in same order as tasks

        Note: T4 - Batches are processed in chunks of BATCH_SIZE (10)
        """
        semaphore = asyncio.Semaphore(max_concurrent)
        all_results = []

        async def execute_with_semaphore(task: Dict[str, Any]) -> ToolResult:
            async with semaphore:
                return await self.execute(task['tool'], task.get('params', {}))

        # T4: Process in batches of 10
        for i in range(0, len(tasks), self.BATCH_SIZE):
            batch = tasks[i:i + self.BATCH_SIZE]
            batch_results = await asyncio.gather(
                *[execute_with_semaphore(task) for task in batch]
            )
            all_results.extend(batch_results)

            # T2: Checkpoint between batches if target is set
            if self._token_rules and len(tasks) > self.BATCH_SIZE:
                self._checkpoint_batch(i // self.BATCH_SIZE, batch_results)

        return all_results

    def _checkpoint_batch(self, batch_num: int, results: List[ToolResult]) -> None:
        """T2: Save checkpoint after each batch."""
        if not self._token_rules:
            return

        checkpoint_data = {
            "batch": batch_num,
            "results_count": len(results),
            "success_count": sum(1 for r in results if r.success),
            "tools": [r.tool for r in results]
        }

        from modules.utils.gate_checkpoint import GateCheckpoint
        cp = GateCheckpoint(self.target)
        cp.save(f"batch_{batch_num}", checkpoint_data)

    def checkpoint_phase(self, phase: str, data: Dict[str, Any]) -> str:
        """
        T2: Checkpoint after completing a phase.

        Args:
            phase: Phase identifier (e.g., "PHASE_1", "intel", "scanning")
            data: Phase results to checkpoint

        Returns:
            Summary string for context
        """
        if TOKEN_OPTIMIZATION_AVAILABLE:
            from modules.utils.gate_checkpoint import checkpoint
            return checkpoint(self.target, phase, data)
        else:
            # Fallback: save to file
            path = Path.home() / "BlackBox" / "targets" / self.target / f"{phase}.json"
            path.parent.mkdir(parents=True, exist_ok=True)
            with open(path, 'w') as f:
                json.dump(data, f, indent=2, default=str)
            return f"{phase} saved to {path}"

    # Convenience methods for common tool categories

    async def run_intel(self, query: str) -> ToolResult:
        """Run intel_comprehensive with all sources."""
        return await self.execute('intel_comprehensive', {'query': query})

    async def run_intel_cve(self, keyword: str, cvss_min: float = 0.0,
                            limit: int = 20) -> ToolResult:
        """Run CVE search."""
        return await self.execute('intel_cve_search', {
            'keyword': keyword,
            'cvssMin': cvss_min,
            'limit': limit
        })

    async def run_intel_tech(self, technology: str,
                             version: Optional[str] = None) -> ToolResult:
        """Get vulnerability context for a technology."""
        params = {'technology': technology}
        if version:
            params['version'] = version
        return await self.execute('intel_tech_vulns', params)

    async def run_nuclei(self, target: str,
                         severity: List[str] = None) -> ToolResult:
        """Run nuclei_scan with specified severity."""
        return await self.execute('nuclei_scan', {
            'target': target,
            'severity': severity or ['high', 'critical']
        })

    async def run_js_analysis(self, urls: List[str]) -> ToolResult:
        """Run js_analyze_batch on multiple URLs."""
        return await self.execute('js_analyze_batch', {'urls': urls})

    async def run_backend_scan(self, service: str, url: str,
                               **kwargs) -> ToolResult:
        """Run backend_access_scan for Supabase/Firebase."""
        params = {'service': service, 'url': url}
        params.update(kwargs)
        return await self.execute('backend_access_scan', params)

    async def run_ai_security(self, url: str,
                              categories: List[str] = None) -> ToolResult:
        """Run AI security test."""
        return await self.execute('ai_security_test', {
            'url': url,
            'categories': categories or ['prompt_injection', 'jailbreak', 'system_prompt_leak']
        })

    async def run_llm_redteam(self, target_url: str,
                              strategies: List[str] = None,
                              vulnerabilities: List[str] = None) -> ToolResult:
        """Run comprehensive LLM red team assessment."""
        params = {'targetUrl': target_url}
        if strategies:
            params['strategies'] = strategies
        if vulnerabilities:
            params['vulnerabilities'] = vulnerabilities
        return await self.execute('llm_redteam_scan', params)

    async def run_cors_scan(self, url: str) -> ToolResult:
        """Run CORS misconfiguration scan."""
        return await self.execute('cors_scan', {
            'targetUrl': url,
            'testNullOrigin': True,
            'testSubdomain': True
        })

    async def run_ssrf_scan(self, url: str, param: str,
                            clouds: List[str] = None) -> ToolResult:
        """Run SSRF scan."""
        return await self.execute('ssrf_scan', {
            'targetUrl': url,
            'param': param,
            'clouds': clouds or ['aws', 'gcp', 'azure']
        })

    async def run_graphql_scan(self, url: str) -> ToolResult:
        """Run GraphQL security scan."""
        return await self.execute('graphql_scan', {
            'graphqlUrl': url,
            'testIntrospection': True,
            'testBatching': True
        })

    async def run_jwt_analyze(self, token: str) -> ToolResult:
        """Analyze JWT token for vulnerabilities."""
        return await self.execute('jwt_analyze', {
            'token': token,
            'testNoneAlg': True,
            'testAlgConfusion': True
        })

    async def run_oauth_scan(self, auth_url: str,
                             categories: List[str] = None) -> ToolResult:
        """Run OAuth security scan."""
        return await self.execute('oauth_scan', {
            'authUrl': auth_url,
            'categories': categories or ['open_redirect', 'state_fixation', 'token_leakage']
        })

    async def run_payment_test(self, url: str,
                               categories: List[str] = None) -> ToolResult:
        """Run payment security test."""
        return await self.execute('payment_security_test', {
            'url': url,
            'categories': categories or ['negative_value', 'currency_confusion', 'quantity_manipulation']
        })

    async def run_waf_bypass(self, domain: str) -> ToolResult:
        """Run WAF bypass scan."""
        return await self.execute('waf_bypass_scan', {'domain': domain})

    async def run_race_condition(self, url: str, payload: Dict[str, Any]) -> ToolResult:
        """Run race condition scan."""
        return await self.execute('race_condition_scan', {
            'url': url,
            'payload': payload
        })

    async def run_api_enumerate(self, base_url: str,
                                wordlist: str = 'common') -> ToolResult:
        """Run API endpoint enumeration."""
        return await self.execute('api_enumerate', {
            'baseUrl': base_url,
            'wordlist': wordlist,
            'detectVersions': True
        })

    async def run_subdomain_takeover(self, subdomains: List[str],
                                      services: List[str] = None) -> ToolResult:
        """Run subdomain takeover scan."""
        return await self.execute('subdomain_takeover_scan', {
            'subdomains': subdomains,
            'services': services or ['aws_s3', 'github_pages', 'heroku', 'azure', 'netlify', 'vercel']
        })

    async def run_stealth_fetch(self, url: str,
                                engine: str = 'auto') -> ToolResult:
        """Fetch URL with stealth browser."""
        return await self.execute('stealth_fetch', {
            'url': url,
            'engine': engine
        })

    async def run_http_smuggling(self, url: str) -> ToolResult:
        """Run HTTP smuggling scan."""
        return await self.execute('http_smuggling_scan', {
            'targetUrl': url,
            'testClTe': True,
            'testTeCl': True
        })

    async def run_ssti_scan(self, url: str, param: str,
                            engines: List[str] = None) -> ToolResult:
        """Run Server-Side Template Injection scan."""
        return await self.execute('ssti_scan', {
            'targetUrl': url,
            'param': param,
            'engines': engines or ['jinja2', 'twig', 'freemarker']
        })

    async def run_command_injection(self, url: str, param: str) -> ToolResult:
        """Run command injection scan."""
        return await self.execute('command_injection_scan', {
            'targetUrl': url,
            'param': param,
            'testTimeBased': True
        })

    async def run_path_traversal(self, url: str, param: str,
                                  depth: int = 10) -> ToolResult:
        """Run path traversal scan."""
        return await self.execute('path_traversal_scan', {
            'targetUrl': url,
            'param': param,
            'testPhpWrappers': True,
            'depth': depth
        })

    async def run_crescendo_attack(self, target_url: str, goal: str,
                                    max_turns: int = 20) -> ToolResult:
        """Run crescendo attack on AI system."""
        return await self.execute('crescendo_attack', {
            'targetUrl': target_url,
            'goal': goal,
            'maxTurns': max_turns
        })

    async def run_indirect_injection(self, target_url: str,
                                      method: str = 'unicode_hidden') -> ToolResult:
        """Run indirect injection test on AI system."""
        return await self.execute('indirect_injection_test', {
            'targetUrl': target_url,
            'method': method
        })

    async def run_hybrid_attack_plan(self, goal_state: Dict[str, Any],
                                      initial_state: Dict[str, Any] = None,
                                      mcts_iterations: int = 1000) -> ToolResult:
        """Plan attack path using hybrid MCTS + RRT* + A*."""
        params = {
            'goalState': goal_state,
            'mctsIterations': mcts_iterations
        }
        if initial_state:
            params['initialState'] = initial_state
        return await self.execute('hybrid_plan_attack', params)


# Synchronous wrapper for non-async contexts
class SyncMCPToolBridge:
    """Synchronous wrapper for MCPToolBridge."""

    def __init__(self, mcp_server_path: str = "G:/.claude-home/mcp-server"):
        self._bridge = MCPToolBridge(mcp_server_path)
        self._loop = None

    def _get_loop(self):
        if self._loop is None or self._loop.is_closed():
            self._loop = asyncio.new_event_loop()
        return self._loop

    def execute(self, tool: str, params: Dict[str, Any],
                timeout: Optional[int] = None) -> ToolResult:
        """Execute tool synchronously."""
        loop = self._get_loop()
        return loop.run_until_complete(
            self._bridge.execute(tool, params, timeout)
        )

    def execute_batch(self, tasks: List[Dict[str, Any]],
                      max_concurrent: int = 5) -> List[ToolResult]:
        """Execute batch synchronously."""
        loop = self._get_loop()
        return loop.run_until_complete(
            self._bridge.execute_batch(tasks, max_concurrent)
        )

    def get_tool_metadata(self, tool: str) -> Optional[ToolMetadata]:
        return self._bridge.get_tool_metadata(tool)

    def list_tools(self, category: Optional[ToolCategory] = None) -> List[str]:
        return self._bridge.list_tools(category)
