"""
Attack Path Router for DeadMan Pen.

Executes ALL viable paths in parallel.
Uses MCTS for path prioritization but executes all paths,
not just the highest-scoring one.
"""

import asyncio
import random
import math
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional, Tuple, Set
from enum import Enum
from collections import defaultdict

from .state import StateManager, AccessLevel, Finding, Severity
from .mcp_bridge import MCPToolBridge, ToolResult
from .parser import ResultParser, ParsedResult


class PathStatus(Enum):
    """Status of an attack path."""
    PENDING = 'pending'
    RUNNING = 'running'
    SUCCESS = 'success'
    PARTIAL = 'partial'
    FAILED = 'failed'
    BLOCKED = 'blocked'


@dataclass
class PathStep:
    """A single step in an attack path."""
    tool: str
    params: Dict[str, Any]
    depends_on: List[str] = field(default_factory=list)  # Previous step IDs
    success_condition: Optional[Callable[[Dict], bool]] = None
    on_success: Optional[str] = None  # Next step ID on success
    on_failure: Optional[str] = None  # Alternative step ID on failure


@dataclass
class AttackPath:
    """
    Represents a complete attack path to execute.

    Paths are sequences of tools that build on each other,
    with conditional branching based on results.
    """
    id: str
    name: str
    category: str  # recon, exploitation, escalation, exfiltration, ai
    steps: List[PathStep]
    priority: int = 50
    target_access: Optional[AccessLevel] = None
    success_condition: Optional[Callable[[Dict], bool]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class PathResult:
    """Result of executing an attack path."""
    path_id: str
    status: PathStatus
    steps_completed: int
    total_steps: int
    findings: List[Finding] = field(default_factory=list)
    access_gained: Optional[AccessLevel] = None
    data_exfiltrated: Dict[str, Any] = field(default_factory=dict)
    tool_results: List[ToolResult] = field(default_factory=list)
    error: Optional[str] = None


class MCTSNode:
    """Node in Monte Carlo Tree Search for path planning."""

    def __init__(self, state: Dict[str, Any], parent: Optional['MCTSNode'] = None,
                 action: Optional[str] = None):
        self.state = state
        self.parent = parent
        self.action = action
        self.children: List['MCTSNode'] = []
        self.visits = 0
        self.value = 0.0
        self.untried_actions: List[str] = []

    def ucb1_score(self, exploration_weight: float = 1.414) -> float:
        """Calculate UCB1 score for node selection."""
        if self.visits == 0:
            return float('inf')

        exploitation = self.value / self.visits
        exploration = exploration_weight * math.sqrt(math.log(self.parent.visits) / self.visits)
        return exploitation + exploration

    def best_child(self, exploration_weight: float = 1.414) -> 'MCTSNode':
        """Select best child using UCB1."""
        return max(self.children, key=lambda c: c.ucb1_score(exploration_weight))


class PathRouter:
    """
    Execute ALL viable paths in parallel.

    Uses MCTS for path prioritization but executes all paths,
    not just the highest-scoring one.
    """

    # Predefined attack path templates
    PATH_TEMPLATES = {
        # Reconnaissance paths
        'tech_recon': AttackPath(
            id='tech_recon',
            name='Technology Reconnaissance',
            category='recon',
            priority=90,
            steps=[
                PathStep('stealth_fetch', {'engine': 'auto'}),
                PathStep('js_analyze_batch', {}, depends_on=['stealth_fetch']),
                PathStep('api_enumerate', {'wordlist': 'common'}),
            ]
        ),

        'subdomain_recon': AttackPath(
            id='subdomain_recon',
            name='Subdomain Enumeration',
            category='recon',
            priority=85,
            steps=[
                PathStep('subdomain_takeover_scan', {'services': ['aws_s3', 'github_pages', 'heroku']}),
            ]
        ),

        # NHI (Non-Human Identity) credential extraction
        'nhi_credential_extraction': AttackPath(
            id='nhi_credential_extraction',
            name='NHI Credential Extraction',
            category='exploitation',
            priority=95,
            steps=[
                PathStep('js_analyze_batch', {}),  # Look for API keys in JS
                PathStep('api_enumerate', {'paths': ['/api/', '/.git/', '/config/']}),
                PathStep('path_traversal_scan', {'param': 'file', 'depth': 10}),
                PathStep('ssrf_scan', {'clouds': ['aws', 'gcp', 'azure']}),  # Cloud metadata for creds
            ],
            target_access=AccessLevel.ADMIN,
            success_condition=lambda r: r.get('credentials_found') or r.get('api_keys_found')
        ),

        # Session artifact exploitation
        'session_exploitation': AttackPath(
            id='session_exploitation',
            name='Session Artifact Exploitation',
            category='exploitation',
            priority=90,
            steps=[
                PathStep('jwt_analyze', {'testNoneAlg': True, 'testAlgConfusion': True}),
                PathStep('cors_auth_scan', {}),
                PathStep('race_condition_scan', {}),  # Session race conditions
            ],
            target_access=AccessLevel.ADMIN,
            success_condition=lambda r: r.get('session_hijack') or r.get('elevated_claims')
        ),

        # IdP trust exploitation
        'idp_trust_exploitation': AttackPath(
            id='idp_trust_exploitation',
            name='Identity Provider Trust Exploitation',
            category='escalation',
            priority=88,
            steps=[
                PathStep('oauth_scan', {'categories': ['open_redirect', 'state_fixation', 'token_leakage']}),
                PathStep('auth_flow_attack', {'attackType': 'mass_assignment'}),
                PathStep('idor_scan', {'testType': 'uuid_manipulation'}),  # Access other users
            ],
            target_access=AccessLevel.ADMIN,
            success_condition=lambda r: r.get('admin_access') or r.get('shadow_admin')
        ),

        # Backend exploitation paths
        'supabase_exploitation': AttackPath(
            id='supabase_exploitation',
            name='Supabase Backend Exploitation',
            category='exploitation',
            priority=90,
            steps=[
                PathStep('backend_access_scan', {'service': 'supabase'}),
                PathStep('db_error_exploit', {'dbType': 'postgres'}, depends_on=['backend_access_scan']),
                PathStep('cloud_storage_enum', {'provider': 'supabase_storage'}),
            ],
            target_access=AccessLevel.ADMIN
        ),

        'firebase_exploitation': AttackPath(
            id='firebase_exploitation',
            name='Firebase Backend Exploitation',
            category='exploitation',
            priority=90,
            steps=[
                PathStep('backend_access_scan', {'service': 'firebase'}),
                PathStep('cloud_storage_enum', {'provider': 'firebase_storage'}),
            ],
            target_access=AccessLevel.ADMIN
        ),

        # JWT escalation path
        'jwt_escalation': AttackPath(
            id='jwt_escalation',
            name='JWT Privilege Escalation',
            category='escalation',
            priority=85,
            steps=[
                PathStep('jwt_analyze', {'testNoneAlg': True}),
                PathStep('jwt_analyze', {'testAlgConfusion': True}),
            ],
            target_access=AccessLevel.ADMIN,
            success_condition=lambda r: r.get('elevated_claims')
        ),

        # IDOR escalation path
        'idor_escalation': AttackPath(
            id='idor_escalation',
            name='IDOR Privilege Escalation',
            category='escalation',
            priority=80,
            steps=[
                PathStep('idor_scan', {'testType': 'sequential'}),
                PathStep('idor_scan', {'testType': 'uuid_manipulation'}),
            ],
            target_access=AccessLevel.ADMIN,
            success_condition=lambda r: r.get('unauthorized_access')
        ),

        # OAuth exploitation path
        'oauth_exploitation': AttackPath(
            id='oauth_exploitation',
            name='OAuth Flow Exploitation',
            category='escalation',
            priority=75,
            steps=[
                PathStep('oauth_scan', {'categories': ['open_redirect']}),
                PathStep('oauth_scan', {'categories': ['state_fixation']}),
                PathStep('oauth_scan', {'categories': ['token_leakage', 'pkce_bypass']}),
            ],
            target_access=AccessLevel.USER,
            success_condition=lambda r: r.get('token_captured')
        ),

        # Payment exploitation
        'payment_exploitation': AttackPath(
            id='payment_exploitation',
            name='Payment System Exploitation',
            category='exploitation',
            priority=85,
            steps=[
                PathStep('payment_injection_scan', {}),
                PathStep('payment_security_test', {'categories': ['negative_value', 'currency_confusion']}),
                PathStep('payment_webhook_test', {}),
            ],
            success_condition=lambda r: r.get('vulnerabilities')
        ),

        # AI/LLM exploitation
        'ai_exploitation': AttackPath(
            id='ai_exploitation',
            name='AI/LLM System Exploitation',
            category='ai',
            priority=70,
            steps=[
                PathStep('ai_security_test', {'categories': ['prompt_injection', 'jailbreak']}),
                PathStep('llm_redteam_scan', {'strategies': ['direct', 'multi_turn']}),
                PathStep('indirect_injection_test', {'method': 'unicode_hidden'}),
                PathStep('crescendo_attack', {'maxTurns': 15}),
            ],
            success_condition=lambda r: r.get('system_prompt_extracted') or r.get('jailbreak_success')
        ),

        # WAF bypass path
        'waf_bypass': AttackPath(
            id='waf_bypass',
            name='WAF/CDN Bypass',
            category='recon',
            priority=70,
            steps=[
                PathStep('waf_bypass_scan', {}),
            ],
            success_condition=lambda r: r.get('origin_ip')
        ),

        # Web cache poisoning
        'cache_poisoning': AttackPath(
            id='cache_poisoning',
            name='Web Cache Poisoning',
            category='exploitation',
            priority=65,
            steps=[
                PathStep('cache_poisoning_scan', {'testUnkeyedHeaders': True, 'testFatGet': True}),
            ],
            success_condition=lambda r: r.get('cache_poisoned')
        ),

        # HTTP smuggling
        'http_smuggling': AttackPath(
            id='http_smuggling',
            name='HTTP Request Smuggling',
            category='exploitation',
            priority=60,
            steps=[
                PathStep('http_smuggling_scan', {'testClTe': True, 'testTeCl': True}),
            ],
            success_condition=lambda r: r.get('smuggling_successful')
        ),

        # GraphQL exploitation
        'graphql_exploitation': AttackPath(
            id='graphql_exploitation',
            name='GraphQL Exploitation',
            category='exploitation',
            priority=75,
            steps=[
                PathStep('graphql_scan', {'testIntrospection': True}),
                PathStep('graphql_scan', {'testBatching': True}),
            ],
            success_condition=lambda r: r.get('introspection_enabled') or r.get('batching_dos')
        ),

        # SSRF cloud metadata
        'ssrf_cloud_metadata': AttackPath(
            id='ssrf_cloud_metadata',
            name='SSRF Cloud Metadata Extraction',
            category='exploitation',
            priority=92,
            steps=[
                PathStep('ssrf_scan', {'clouds': ['aws']}),
                PathStep('ssrf_scan', {'clouds': ['gcp']}),
                PathStep('ssrf_scan', {'clouds': ['azure']}),
            ],
            target_access=AccessLevel.ADMIN,
            success_condition=lambda r: r.get('cloud_metadata')
        ),

        # CI/CD secret extraction
        'cicd_secrets': AttackPath(
            id='cicd_secrets',
            name='CI/CD Secret Extraction',
            category='exploitation',
            priority=88,
            steps=[
                PathStep('api_enumerate', {'paths': ['/.github/', '/.gitlab-ci.yml', '/Jenkinsfile', '/.circleci/']}),
                PathStep('path_traversal_scan', {'files': ['.env', '.env.local', 'config.json', 'secrets.json']}),
                PathStep('js_analyze_batch', {}),  # Look for build artifact secrets
            ],
            success_condition=lambda r: r.get('secrets_found')
        ),
    }

    def __init__(self, state_manager: StateManager, tool_bridge: MCPToolBridge,
                 parser: ResultParser, config: Dict[str, Any] = None):
        """Initialize path router."""
        self.state = state_manager
        self.tools = tool_bridge
        self.parser = parser
        self.config = config or {}
        self._active_paths: Dict[str, PathStatus] = {}
        self._path_results: Dict[str, PathResult] = {}

    def discover_paths(self, context: Dict[str, Any]) -> List[AttackPath]:
        """
        Identify all viable attack paths from current state.

        Args:
            context: Current assessment context

        Returns:
            List of viable AttackPaths sorted by priority
        """
        viable_paths = []

        # Check each template for viability
        for path_id, path in self.PATH_TEMPLATES.items():
            if self._is_path_viable(path, context):
                # Create instance with context-specific parameters
                path_instance = self._instantiate_path(path, context)
                viable_paths.append(path_instance)

        # Add custom paths based on detected technologies
        custom_paths = self._generate_custom_paths(context)
        viable_paths.extend(custom_paths)

        # Sort by priority
        return sorted(viable_paths, key=lambda p: p.priority, reverse=True)

    def _is_path_viable(self, path: AttackPath, context: Dict[str, Any]) -> bool:
        """Check if a path is viable given current context."""
        # Check if already completed or failed
        if path.id in self._active_paths:
            status = self._active_paths[path.id]
            if status in [PathStatus.SUCCESS, PathStatus.RUNNING]:
                return False

        # Check technology requirements
        tech_requirements = {
            'supabase_exploitation': lambda c: c.get('supabase_url'),
            'firebase_exploitation': lambda c: c.get('firebase_project'),
            'jwt_escalation': lambda c: c.get('jwt_tokens'),
            'oauth_exploitation': lambda c: c.get('oauth_endpoints'),
            'payment_exploitation': lambda c: c.get('checkout_endpoint'),
            'ai_exploitation': lambda c: c.get('ai_endpoints'),
            'graphql_exploitation': lambda c: c.get('graphql_endpoint'),
        }

        if path.id in tech_requirements:
            if not tech_requirements[path.id](context):
                return False

        # Check access level requirements
        if path.category == 'escalation':
            current_access = context.get('access_level', AccessLevel.ANONYMOUS)
            if isinstance(current_access, str):
                current_access = AccessLevel[current_access.upper()]

            # Don't attempt escalation if already at target
            if path.target_access and current_access >= path.target_access:
                return False

        return True

    def _instantiate_path(self, template: AttackPath, context: Dict[str, Any]) -> AttackPath:
        """Create path instance with context-specific parameters."""
        import copy
        path = copy.deepcopy(template)

        # Fill in context-specific parameters
        for step in path.steps:
            # Fill URLs
            if 'url' not in step.params and context.get('target_url'):
                step.params['url'] = context['target_url']
            if 'targetUrl' not in step.params and context.get('target_url'):
                step.params['targetUrl'] = context['target_url']
            if 'baseUrl' not in step.params and context.get('api_base'):
                step.params['baseUrl'] = context['api_base']

            # Fill tokens
            if step.tool == 'jwt_analyze' and 'token' not in step.params:
                if context.get('jwt_tokens'):
                    step.params['token'] = context['jwt_tokens'][0]

            # Fill backend specifics
            if step.tool == 'backend_access_scan':
                if step.params.get('service') == 'supabase' and context.get('supabase_url'):
                    step.params['url'] = context['supabase_url']
                    if context.get('extracted_keys', {}).get('supabase_anon'):
                        step.params['anon_key'] = context['extracted_keys']['supabase_anon']
                elif step.params.get('service') == 'firebase' and context.get('firebase_project'):
                    step.params['project_id'] = context['firebase_project']

            # Fill OAuth
            if step.tool == 'oauth_scan' and 'authUrl' not in step.params:
                if context.get('oauth_endpoints'):
                    step.params['authUrl'] = context['oauth_endpoints'][0]

            # Fill payment
            if step.tool in ['payment_injection_scan', 'payment_security_test']:
                if context.get('checkout_endpoint'):
                    step.params['url'] = context['checkout_endpoint']
                if context.get('observed_checkout_payload'):
                    step.params['base_payload'] = context['observed_checkout_payload']

            # Fill AI
            if step.tool in ['ai_security_test', 'llm_redteam_scan', 'crescendo_attack', 'indirect_injection_test']:
                if context.get('ai_endpoints'):
                    step.params['targetUrl'] = context['ai_endpoints'][0]
                    step.params['url'] = context['ai_endpoints'][0]

            # Fill SSRF
            if step.tool == 'ssrf_scan' and 'param' not in step.params:
                step.params['param'] = 'url'  # Default param

            # Fill subdomains
            if step.tool == 'subdomain_takeover_scan' and 'subdomains' not in step.params:
                if context.get('subdomains'):
                    step.params['subdomains'] = context['subdomains']
                elif context.get('domain'):
                    step.params['subdomains'] = [context['domain']]

            # Fill JS URLs
            if step.tool == 'js_analyze_batch' and 'urls' not in step.params:
                if context.get('js_bundles'):
                    step.params['urls'] = context['js_bundles']

        return path

    def _generate_custom_paths(self, context: Dict[str, Any]) -> List[AttackPath]:
        """Generate custom paths based on detected context."""
        custom_paths = []

        # Generate IDOR paths for each detected user parameter
        for i, param in enumerate(context.get('user_id_params', [])[:5]):
            custom_paths.append(AttackPath(
                id=f'idor_custom_{i}',
                name=f'IDOR via {param}',
                category='escalation',
                priority=75 - i,
                steps=[
                    PathStep('idor_scan', {
                        'url': context.get('user_endpoint', context.get('target_url', '')),
                        'param': param,
                        'testType': 'sequential'
                    }),
                ],
                target_access=AccessLevel.ADMIN,
                success_condition=lambda r: r.get('unauthorized_access')
            ))

        # Generate SSTI paths for each detected template parameter
        for i, (url, param) in enumerate(context.get('template_params', [])[:3]):
            custom_paths.append(AttackPath(
                id=f'ssti_custom_{i}',
                name=f'SSTI via {param}',
                category='exploitation',
                priority=70 - i,
                steps=[
                    PathStep('ssti_scan', {
                        'targetUrl': url,
                        'param': param,
                        'engines': ['jinja2', 'twig', 'freemarker']
                    }),
                ],
                success_condition=lambda r: r.get('ssti_confirmed')
            ))

        return custom_paths

    async def execute_parallel(self, paths: List[AttackPath],
                               max_concurrent: int = 5) -> List[PathResult]:
        """
        Execute all paths concurrently using worker pool.

        Args:
            paths: List of attack paths to execute
            max_concurrent: Maximum concurrent path executions

        Returns:
            List of PathResults
        """
        semaphore = asyncio.Semaphore(max_concurrent)

        async def execute_with_semaphore(path: AttackPath) -> PathResult:
            async with semaphore:
                return await self._execute_path(path)

        results = await asyncio.gather(
            *[execute_with_semaphore(path) for path in paths],
            return_exceptions=True
        )

        # Process results
        processed_results = []
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                processed_results.append(PathResult(
                    path_id=paths[i].id,
                    status=PathStatus.FAILED,
                    steps_completed=0,
                    total_steps=len(paths[i].steps),
                    error=str(result)
                ))
            else:
                processed_results.append(result)

        return processed_results

    async def _execute_path(self, path: AttackPath) -> PathResult:
        """Execute a single attack path."""
        self._active_paths[path.id] = PathStatus.RUNNING

        steps_completed = 0
        findings = []
        tool_results = []
        access_gained = None
        data_exfiltrated = {}
        aggregated_results = {}

        try:
            for step in path.steps:
                # Check dependencies
                if step.depends_on:
                    # For now, just ensure previous steps completed
                    pass

                # Execute tool
                result = await self.tools.execute(step.tool, step.params)
                tool_results.append(result)

                if result.success:
                    steps_completed += 1

                    # Parse result
                    parsed = self.parser.parse(step.tool, result.data, path.category)
                    findings.extend(parsed.findings)

                    # Check for access gain
                    if parsed.access_granted:
                        if access_gained is None or parsed.access_granted.value > access_gained.value:
                            access_gained = parsed.access_granted

                    # Collect assets
                    for asset in parsed.assets:
                        data_exfiltrated[asset.name] = asset.metadata

                    # Aggregate results for conditions
                    aggregated_results.update(result.data)

                    # Check step success condition
                    if step.success_condition and step.success_condition(result.data):
                        # Could branch to success path
                        pass

                else:
                    # Step failed
                    if step.on_failure:
                        # Could branch to failure path
                        pass

            # Determine overall status
            if steps_completed == len(path.steps):
                if path.success_condition and path.success_condition(aggregated_results):
                    status = PathStatus.SUCCESS
                elif access_gained or findings:
                    status = PathStatus.SUCCESS
                else:
                    status = PathStatus.PARTIAL
            elif steps_completed > 0:
                status = PathStatus.PARTIAL
            else:
                status = PathStatus.FAILED

            self._active_paths[path.id] = status

            return PathResult(
                path_id=path.id,
                status=status,
                steps_completed=steps_completed,
                total_steps=len(path.steps),
                findings=findings,
                access_gained=access_gained,
                data_exfiltrated=data_exfiltrated,
                tool_results=tool_results
            )

        except Exception as e:
            self._active_paths[path.id] = PathStatus.FAILED
            return PathResult(
                path_id=path.id,
                status=PathStatus.FAILED,
                steps_completed=steps_completed,
                total_steps=len(path.steps),
                findings=findings,
                tool_results=tool_results,
                error=str(e)
            )

    def merge_results(self, results: List[PathResult],
                      context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Merge findings from all paths into unified context.

        Args:
            results: List of PathResults from parallel execution
            context: Current assessment context

        Returns:
            Updated context with merged results
        """
        merged = dict(context)

        # Merge findings
        all_findings = merged.get('findings', [])
        for result in results:
            all_findings.extend(result.findings)
        merged['findings'] = all_findings
        merged['vulns_found'] = len(all_findings) > 0

        # Track highest access gained
        highest_access = merged.get('access_level', AccessLevel.ANONYMOUS)
        if isinstance(highest_access, str):
            highest_access = AccessLevel[highest_access.upper()]

        for result in results:
            if result.access_gained and result.access_gained.value > highest_access.value:
                highest_access = result.access_gained

        merged['access_level'] = highest_access

        # Merge exfiltrated data
        exfil_data = merged.get('exfiltrated_data', {})
        for result in results:
            exfil_data.update(result.data_exfiltrated)
        merged['exfiltrated_data'] = exfil_data

        # Track path statuses
        path_statuses = merged.get('path_statuses', {})
        for result in results:
            path_statuses[result.path_id] = result.status.value
        merged['path_statuses'] = path_statuses

        # Extract new targets from findings (endpoints, subdomains, etc.)
        for result in results:
            for finding in result.findings:
                if finding.evidence:
                    # Extract URLs
                    import re
                    urls = re.findall(r'https?://[^\s"\'<>]+', str(finding.evidence))
                    endpoints = merged.get('endpoints', [])
                    endpoints.extend(urls)
                    merged['endpoints'] = list(set(endpoints))

        return merged

    def get_mcts_planned_path(self, context: Dict[str, Any],
                              goal_state: Dict[str, Any],
                              iterations: int = 1000) -> List[str]:
        """
        Use MCTS to plan optimal attack path sequence.

        Args:
            context: Current state
            goal_state: Target state to achieve
            iterations: Number of MCTS iterations

        Returns:
            List of path IDs in recommended execution order
        """
        root = MCTSNode(state=context)
        root.untried_actions = list(self.PATH_TEMPLATES.keys())

        for _ in range(iterations):
            # Selection
            node = root
            while node.untried_actions == [] and node.children:
                node = node.best_child()

            # Expansion
            if node.untried_actions:
                action = random.choice(node.untried_actions)
                node.untried_actions.remove(action)

                # Simulate state after action
                new_state = self._simulate_action(node.state, action)
                child = MCTSNode(state=new_state, parent=node, action=action)
                child.untried_actions = [a for a in self.PATH_TEMPLATES.keys()
                                         if a != action]
                node.children.append(child)
                node = child

            # Simulation
            reward = self._simulate_to_terminal(node.state, goal_state)

            # Backpropagation
            while node is not None:
                node.visits += 1
                node.value += reward
                node = node.parent

        # Extract best path sequence
        path_sequence = []
        node = root
        while node.children:
            best = max(node.children, key=lambda c: c.visits)
            if best.action:
                path_sequence.append(best.action)
            node = best

        return path_sequence

    def _simulate_action(self, state: Dict[str, Any], action: str) -> Dict[str, Any]:
        """Simulate state after taking an action."""
        new_state = dict(state)
        path = self.PATH_TEMPLATES.get(action)

        if path:
            # Simulate potential outcomes
            if path.target_access:
                # 30% chance of achieving target access
                if random.random() < 0.3:
                    current = new_state.get('access_level', AccessLevel.ANONYMOUS)
                    if isinstance(current, str):
                        current = AccessLevel[current.upper()]
                    if path.target_access.value > current.value:
                        new_state['access_level'] = path.target_access

            # 50% chance of finding vulnerabilities
            if random.random() < 0.5:
                new_state['vulns_found'] = True
                new_state['finding_count'] = new_state.get('finding_count', 0) + random.randint(1, 5)

        return new_state

    def _simulate_to_terminal(self, state: Dict[str, Any],
                              goal_state: Dict[str, Any]) -> float:
        """Simulate from state to terminal and return reward."""
        reward = 0.0

        # Check goal achievement
        if goal_state.get('access'):
            target_access = AccessLevel[goal_state['access'].upper()]
            current = state.get('access_level', AccessLevel.ANONYMOUS)
            if isinstance(current, str):
                current = AccessLevel[current.upper()]
            if current.value >= target_access.value:
                reward += 1.0
            else:
                reward += current.value / target_access.value * 0.5

        if goal_state.get('vulns'):
            if state.get('vulns_found'):
                reward += 0.5
            finding_count = state.get('finding_count', 0)
            reward += min(finding_count / 10, 0.5)

        return reward
