"""
Phase Transition Rules for DeadMan Pen.

Procedural rules that determine when to transition between
assessment phases based on findings and context.
"""

from typing import List, Optional, Union
from dataclasses import dataclass, field

# Import from engine - using relative import would work in package context
# For standalone, we define the types here
@dataclass
class PhaseTransition:
    """Represents a phase transition decision."""
    from_phase: str
    to_phase: str
    priority: int = 50
    parallel: bool = False
    reason: str = ''
    context_updates: dict = field(default_factory=dict)
    tools: list = field(default_factory=list)

    @classmethod
    def stay(cls, phase: str, reason: str = '') -> 'PhaseTransition':
        return cls(from_phase=phase, to_phase=phase, reason=reason)

    @classmethod
    def continue_phase(cls, phase: str, tools: list, reason: str = '') -> 'PhaseTransition':
        return cls(from_phase=phase, to_phase=phase, tools=tools, reason=reason)


def evaluate_p1_transition(ctx) -> Union[PhaseTransition, List[PhaseTransition]]:
    """
    P1 Intelligence -> P2 Weaponization

    IF tech_stack identified AND vulnerabilities discovered
    THEN transition to P2 with weaponization targets

    IF ai_endpoints found
    THEN branch to P9 (AI Influence) in parallel

    IF backend_direct_access detected
    THEN branch to P3 immediately (fast path)
    """
    transitions = []

    # Check if we have enough intel to proceed
    has_tech_intel = bool(ctx.tech_stack) or bool(ctx.endpoints)
    has_vuln_intel = ctx.vulns_found or bool(ctx.intel_findings)

    # Fast path: IF direct backend access detected, skip to P3
    if ctx.has_backend_direct_access:
        transitions.append(PhaseTransition(
            from_phase='P1',
            to_phase='P3',
            priority=95,
            reason='Direct backend access detected - fast path to initial access',
            context_updates={'fast_path': True}
        ))

    # IF AI endpoints found, branch to P9 in parallel
    if ctx.ai_endpoints:
        transitions.append(PhaseTransition(
            from_phase='P1',
            to_phase='P9',
            priority=70,
            parallel=True,
            reason='AI endpoints detected - parallel AI assessment',
            context_updates={'ai_targets': ctx.ai_endpoints}
        ))

    # Standard path: IF intel gathered, proceed to P2
    if has_tech_intel and has_vuln_intel:
        transitions.append(PhaseTransition(
            from_phase='P1',
            to_phase='P2',
            priority=80,
            reason='Sufficient intelligence gathered',
            context_updates={
                'tech_intel': [t.name for t in ctx.tech_stack] if ctx.tech_stack else [],
                'endpoint_count': len(ctx.endpoints),
            }
        ))
    elif has_tech_intel:
        # Have some intel, can proceed with caution
        transitions.append(PhaseTransition(
            from_phase='P1',
            to_phase='P2',
            priority=60,
            reason='Partial intel gathered - proceeding to weaponization',
        ))

    # IF nothing found, continue P1 with more aggressive recon
    if not transitions:
        return PhaseTransition.continue_phase(
            'P1',
            tools=['stealth_fetch', 'api_enumerate', 'js_analyze_batch', 'subdomain_takeover_scan'],
            reason='Insufficient intel - continuing reconnaissance'
        )

    return transitions


def evaluate_p2_transition(ctx) -> Union[PhaseTransition, List[PhaseTransition]]:
    """
    P2 Weaponization -> P3 Initial Access

    IF exploitable vulnerabilities identified
    THEN transition to P3 with attack vectors

    IF high-value targets identified (payment, auth, admin)
    THEN prioritize those vectors
    """
    transitions = []

    # Check for exploitable findings
    severity_counts = ctx.get_severity_counts()
    critical_count = severity_counts.get('critical', 0)
    high_count = severity_counts.get('high', 0)

    # IF critical vulns found, fast path to exploitation
    if critical_count > 0:
        transitions.append(PhaseTransition(
            from_phase='P2',
            to_phase='P3',
            priority=95,
            reason=f'{critical_count} critical vulnerabilities ready for exploitation',
            context_updates={'exploit_priority': 'critical'}
        ))

    # IF high vulns found, proceed to P3
    if high_count > 0:
        transitions.append(PhaseTransition(
            from_phase='P2',
            to_phase='P3',
            priority=80,
            reason=f'{high_count} high severity vulnerabilities identified',
        ))

    # Check for high-value targets
    if ctx.checkout_endpoint or ctx.has_technology('stripe') or ctx.has_technology('payment'):
        transitions.append(PhaseTransition(
            from_phase='P2',
            to_phase='P3',
            priority=85,
            reason='Payment system detected - high value target',
            tools=['payment_injection_scan', 'payment_security_test'],
        ))

    if ctx.oauth_endpoints:
        transitions.append(PhaseTransition(
            from_phase='P2',
            to_phase='P3',
            priority=82,
            reason='OAuth endpoints detected',
            tools=['oauth_scan'],
        ))

    # IF nothing specific, proceed with general P3
    if not transitions:
        return PhaseTransition(
            from_phase='P2',
            to_phase='P3',
            priority=50,
            reason='Proceeding to initial access phase',
        )

    return transitions


def evaluate_p3_transition(ctx) -> Union[PhaseTransition, List[PhaseTransition]]:
    """
    P3 Initial Access -> Multiple possible transitions

    IF admin_access obtained THEN skip to P8 (Exfil)
    IF user_access obtained THEN proceed to P5 (Escalation)
    IF no_access but vulns found THEN continue P3 with different vectors
    IF backend_direct_access THEN branch to P6 (Discovery) + P8 (Exfil)
    """
    transitions = []

    # Fast path: IF admin/root access, jump to exfiltration
    if ctx.access_level.value >= 2:  # ADMIN or ROOT
        transitions.append(PhaseTransition(
            from_phase='P3',
            to_phase='P8',
            priority=100,
            reason=f'{ctx.access_level.name} access achieved - proceeding to exfiltration',
        ))

        # Also do discovery in parallel
        transitions.append(PhaseTransition(
            from_phase='P3',
            to_phase='P6',
            priority=90,
            parallel=True,
            reason='Enumerating accessible resources',
        ))

    # IF user access, proceed to escalation
    elif ctx.access_level.value >= 1:  # USER
        transitions.append(PhaseTransition(
            from_phase='P3',
            to_phase='P5',
            priority=85,
            reason='User access obtained - attempting privilege escalation',
        ))

    # IF backend direct access (different from auth access)
    if ctx.has_backend_direct_access:
        transitions.append(PhaseTransition(
            from_phase='P3',
            to_phase='P6',
            priority=90,
            parallel=True,
            reason='Direct backend access - enumerating resources',
        ))
        transitions.append(PhaseTransition(
            from_phase='P3',
            to_phase='P8',
            priority=85,
            parallel=True,
            reason='Direct backend access - data exfiltration opportunity',
        ))

    # IF vulnerabilities found but no access yet
    if ctx.vulns_found and ctx.access_level.value == 0:
        # Try different attack vectors
        transitions.append(PhaseTransition.continue_phase(
            'P3',
            tools=['cors_scan', 'ssrf_scan', 'race_condition_scan', 'ssti_scan'],
            reason='Access not yet achieved - trying additional vectors'
        ))

    # IF nothing working, proceed to P4 for more aggressive execution
    if not transitions:
        return PhaseTransition(
            from_phase='P3',
            to_phase='P4',
            priority=50,
            reason='Initial access attempts complete - proceeding to execution phase',
        )

    return transitions


def evaluate_p4_transition(ctx) -> Union[PhaseTransition, List[PhaseTransition]]:
    """
    P4 Execution -> P5 Escalation or P6 Discovery

    IF code execution achieved THEN proceed to P5 or P6
    IF access gained THEN escalate or enumerate
    """
    transitions = []

    # Check for code execution indicators
    has_code_exec = any(
        'rce' in str(f.title).lower() or
        'command_injection' in str(f.tool).lower() or
        'ssti' in str(f.tool).lower()
        for f in ctx.findings
    )

    if has_code_exec:
        transitions.append(PhaseTransition(
            from_phase='P4',
            to_phase='P6',
            priority=90,
            reason='Code execution achieved - enumerating environment',
        ))
        transitions.append(PhaseTransition(
            from_phase='P4',
            to_phase='P5',
            priority=85,
            parallel=True,
            reason='Attempting privilege escalation from code execution',
        ))

    # IF significant access
    if ctx.access_level.value >= 1:
        transitions.append(PhaseTransition(
            from_phase='P4',
            to_phase='P5',
            priority=80,
            reason='Access obtained - escalation phase',
        ))

    # Default: proceed to P5
    if not transitions:
        return PhaseTransition(
            from_phase='P4',
            to_phase='P5',
            priority=50,
            reason='Execution phase complete',
        )

    return transitions


def evaluate_p5_transition(ctx) -> Union[PhaseTransition, List[PhaseTransition]]:
    """
    P5 Privilege Escalation -> P6 Discovery or P8 Exfil

    IF escalation successful THEN proceed to discovery/exfil
    IF admin/root achieved THEN fast path to exfil
    """
    transitions = []

    # IF admin/root
    if ctx.access_level.value >= 2:
        transitions.append(PhaseTransition(
            from_phase='P5',
            to_phase='P8',
            priority=95,
            reason=f'Escalated to {ctx.access_level.name} - exfiltration phase',
        ))
        transitions.append(PhaseTransition(
            from_phase='P5',
            to_phase='P6',
            priority=90,
            parallel=True,
            reason='Discovering accessible resources',
        ))

    # IF user but not admin yet
    elif ctx.access_level.value >= 1:
        # Continue escalation attempts
        transitions.append(PhaseTransition.continue_phase(
            'P5',
            tools=['jwt_analyze', 'idor_scan', 'race_condition_scan'],
            reason='User access - continuing escalation attempts'
        ))

        # Also start discovery
        transitions.append(PhaseTransition(
            from_phase='P5',
            to_phase='P6',
            priority=70,
            parallel=True,
            reason='Parallel discovery with user access',
        ))

    # Default: proceed to discovery
    if not transitions:
        return PhaseTransition(
            from_phase='P5',
            to_phase='P6',
            priority=50,
            reason='Escalation phase complete',
        )

    return transitions


def evaluate_p6_transition(ctx) -> Union[PhaseTransition, List[PhaseTransition]]:
    """
    P6 Discovery -> P7 Lateral Movement or P8 Exfil

    IF additional targets discovered THEN branch to P7
    IF valuable data found THEN proceed to P8
    """
    transitions = []

    # Check for additional targets (subdomains, internal hosts)
    if ctx.subdomains or ctx.endpoints:
        transitions.append(PhaseTransition(
            from_phase='P6',
            to_phase='P7',
            priority=75,
            reason='Additional targets discovered - lateral movement',
        ))

    # Check for valuable data
    assets_found = bool(ctx.exfiltrated_data) if hasattr(ctx, 'exfiltrated_data') else False
    if assets_found or ctx.access_level.value >= 1:
        transitions.append(PhaseTransition(
            from_phase='P6',
            to_phase='P8',
            priority=80,
            reason='Valuable data identified - exfiltration phase',
        ))

    # Default: proceed to P8
    if not transitions:
        return PhaseTransition(
            from_phase='P6',
            to_phase='P8',
            priority=50,
            reason='Discovery complete',
        )

    return transitions


def evaluate_p7_transition(ctx) -> Union[PhaseTransition, List[PhaseTransition]]:
    """
    P7 Lateral Movement -> P8 Exfil or loop back

    IF new access gained THEN loop to P5/P6
    IF movement exhausted THEN proceed to P8
    """
    transitions = []

    # IF access expanded, loop back for more escalation
    if ctx.access_level.value >= 2:
        transitions.append(PhaseTransition(
            from_phase='P7',
            to_phase='P8',
            priority=90,
            reason='Lateral movement successful - exfiltration',
        ))
    elif ctx.access_level.value >= 1:
        transitions.append(PhaseTransition(
            from_phase='P7',
            to_phase='P5',
            priority=70,
            reason='New access gained - attempting escalation',
        ))

    # Default: proceed to exfil
    if not transitions:
        return PhaseTransition(
            from_phase='P7',
            to_phase='P8',
            priority=50,
            reason='Lateral movement complete',
        )

    return transitions


def evaluate_p8_transition(ctx) -> Union[PhaseTransition, List[PhaseTransition]]:
    """
    P8 Exfiltration -> Complete or loop

    IF goals not met THEN loop back to earlier phases
    IF goals met THEN complete assessment
    """
    # P8 is typically the end phase
    # Could loop back if more targets identified

    if ctx.subdomains and len(ctx.subdomains) > 10:
        return PhaseTransition(
            from_phase='P8',
            to_phase='P7',
            priority=60,
            reason='Additional targets remain - continuing lateral movement',
        )

    # Assessment complete indicator
    return PhaseTransition.stay('P8', reason='Exfiltration phase - assessment winding down')


def evaluate_p9_transition(ctx) -> Union[PhaseTransition, List[PhaseTransition]]:
    """
    P9 AI Influence -> Complete or integrate findings

    IF AI compromised THEN may enable other attacks
    IF system prompt extracted THEN valuable intel
    """
    transitions = []

    # Check for AI-specific findings
    ai_findings = [f for f in ctx.findings if 'ai' in f.tool.lower() or 'llm' in f.tool.lower()]

    if ai_findings:
        # AI findings may inform other attacks
        transitions.append(PhaseTransition(
            from_phase='P9',
            to_phase='P3',
            priority=65,
            reason='AI findings may enable additional attack vectors',
            context_updates={'ai_intel': [f.title for f in ai_findings]}
        ))

    # P9 can run in parallel, so just stay if nothing specific
    return transitions or [PhaseTransition.stay('P9', reason='AI assessment continues')]


# Mapping for dynamic lookup
PHASE_EVALUATORS = {
    'P1': evaluate_p1_transition,
    'P2': evaluate_p2_transition,
    'P3': evaluate_p3_transition,
    'P4': evaluate_p4_transition,
    'P5': evaluate_p5_transition,
    'P6': evaluate_p6_transition,
    'P7': evaluate_p7_transition,
    'P8': evaluate_p8_transition,
    'P9': evaluate_p9_transition,
}


def evaluate_transition(ctx) -> Union[PhaseTransition, List[PhaseTransition]]:
    """Evaluate transition for any phase."""
    evaluator = PHASE_EVALUATORS.get(ctx.current_phase)
    if evaluator:
        return evaluator(ctx)
    return PhaseTransition.stay(ctx.current_phase, reason='Unknown phase')
