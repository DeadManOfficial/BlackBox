"""
SQLite-backed persistent state management for DeadMan Pen.

Provides full persistence for assessments, findings, access levels,
assets, tool executions, and decision audit trails.
"""

import sqlite3
import json
import hashlib
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
from contextlib import contextmanager


class AccessLevel(Enum):
    """Access level hierarchy."""
    ANONYMOUS = 0
    USER = 1
    ADMIN = 2
    ROOT = 3

    def __ge__(self, other):
        if isinstance(other, AccessLevel):
            return self.value >= other.value
        return NotImplemented

    def __gt__(self, other):
        if isinstance(other, AccessLevel):
            return self.value > other.value
        return NotImplemented

    def __le__(self, other):
        if isinstance(other, AccessLevel):
            return self.value <= other.value
        return NotImplemented

    def __lt__(self, other):
        if isinstance(other, AccessLevel):
            return self.value < other.value
        return NotImplemented


class Severity(Enum):
    """Finding severity levels."""
    CRITICAL = 'critical'
    HIGH = 'high'
    MEDIUM = 'medium'
    LOW = 'low'
    INFO = 'info'


class FindingType(Enum):
    """Types of findings."""
    VULNERABILITY = 'vulnerability'
    INFO = 'info'
    ASSET = 'asset'
    ACCESS = 'access'


class AssetType(Enum):
    """Types of acquired assets."""
    DATABASE = 'database'
    SOURCE_CODE = 'source_code'
    API_KEY = 'api_key'
    PII = 'pii'
    CONFIG = 'config'
    CREDENTIALS = 'credentials'


class TaskStatus(Enum):
    """Task status levels."""
    PENDING = 'pending'
    IN_PROGRESS = 'in_progress'
    COMPLETED = 'completed'
    BLOCKED = 'blocked'


class TaskPriority(Enum):
    """Task priority levels."""
    CRITICAL = 'critical'
    HIGH = 'high'
    MEDIUM = 'medium'
    LOW = 'low'


@dataclass
class Finding:
    """Represents a discovered finding."""
    phase: str
    tool: str
    type: FindingType
    severity: Severity
    title: str
    description: str
    evidence: Dict[str, Any] = field(default_factory=dict)
    cvss_score: Optional[float] = None
    cve_ids: List[str] = field(default_factory=list)
    mitre_techniques: List[str] = field(default_factory=list)
    remediation: Optional[str] = None
    id: Optional[int] = None
    assessment_id: Optional[int] = None
    discovered_at: Optional[datetime] = None


@dataclass
class AccessRecord:
    """Records access level achievement."""
    level: AccessLevel
    context: str
    credentials: Dict[str, Any] = field(default_factory=dict)
    id: Optional[int] = None
    assessment_id: Optional[int] = None
    achieved_at: Optional[datetime] = None


@dataclass
class Asset:
    """Represents an acquired asset."""
    type: AssetType
    name: str
    location: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    content_hash: Optional[str] = None
    id: Optional[int] = None
    assessment_id: Optional[int] = None
    acquired_at: Optional[datetime] = None


@dataclass
class ToolExecution:
    """Records a tool execution for audit trail."""
    phase: str
    tool: str
    params: Dict[str, Any]
    result: Dict[str, Any]
    duration_ms: int
    id: Optional[int] = None
    assessment_id: Optional[int] = None
    executed_at: Optional[datetime] = None


@dataclass
class Decision:
    """Records a decision for audit trail."""
    rule_name: str
    condition_met: str
    action_taken: str
    context_before: Dict[str, Any]
    context_after: Dict[str, Any]
    id: Optional[int] = None
    assessment_id: Optional[int] = None
    decided_at: Optional[datetime] = None


@dataclass
class Task:
    """Represents a task in the assessment workflow."""
    title: str
    description: str
    status: TaskStatus
    priority: TaskPriority
    phase: Optional[str] = None
    notes: Optional[str] = None
    findings: List[str] = field(default_factory=list)
    blocked_by: List[int] = field(default_factory=list)
    id: Optional[int] = None
    assessment_id: Optional[int] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None


@dataclass
class AssessmentState:
    """Complete assessment state for resume capability."""
    id: int
    target: str
    domain: Optional[str]
    status: str
    current_phase: str
    config: Dict[str, Any]
    started_at: datetime
    updated_at: Optional[datetime]
    completed_at: Optional[datetime]
    findings: List[Finding] = field(default_factory=list)
    access_levels: List[AccessRecord] = field(default_factory=list)
    assets: List[Asset] = field(default_factory=list)
    tool_executions: List[ToolExecution] = field(default_factory=list)
    decisions: List[Decision] = field(default_factory=list)


class StateManager:
    """
    SQLite-backed state management with full persistence.

    Tables:
    - assessments: Target metadata, status, timestamps
    - findings: All discovered vulnerabilities
    - assets: Acquired assets (keys, data, etc.)
    - access_levels: Current access state per target
    - tool_executions: Audit trail of all tool runs
    - decisions: Decision history with reasoning
    """

    SCHEMA = """
    -- Assessments table
    CREATE TABLE IF NOT EXISTS assessments (
        id INTEGER PRIMARY KEY,
        target TEXT NOT NULL,
        domain TEXT,
        status TEXT DEFAULT 'active',
        current_phase TEXT DEFAULT 'P1',
        started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP,
        completed_at TIMESTAMP,
        config JSON
    );

    -- Findings table
    CREATE TABLE IF NOT EXISTS findings (
        id INTEGER PRIMARY KEY,
        assessment_id INTEGER REFERENCES assessments(id),
        phase TEXT,
        tool TEXT,
        type TEXT,
        severity TEXT,
        title TEXT,
        description TEXT,
        evidence JSON,
        cvss_score REAL,
        cve_ids JSON,
        mitre_techniques JSON,
        remediation TEXT,
        discovered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    -- Access levels table
    CREATE TABLE IF NOT EXISTS access_levels (
        id INTEGER PRIMARY KEY,
        assessment_id INTEGER REFERENCES assessments(id),
        level TEXT,
        context TEXT,
        credentials JSON,
        achieved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    -- Assets table
    CREATE TABLE IF NOT EXISTS assets (
        id INTEGER PRIMARY KEY,
        assessment_id INTEGER REFERENCES assessments(id),
        type TEXT,
        name TEXT,
        location TEXT,
        content_hash TEXT,
        metadata JSON,
        acquired_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    -- Tool executions (audit trail)
    CREATE TABLE IF NOT EXISTS tool_executions (
        id INTEGER PRIMARY KEY,
        assessment_id INTEGER REFERENCES assessments(id),
        phase TEXT,
        tool TEXT,
        params JSON,
        result JSON,
        duration_ms INTEGER,
        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    -- Decisions (reasoning audit trail)
    CREATE TABLE IF NOT EXISTS decisions (
        id INTEGER PRIMARY KEY,
        assessment_id INTEGER REFERENCES assessments(id),
        rule_name TEXT,
        condition_met TEXT,
        action_taken TEXT,
        context_before JSON,
        context_after JSON,
        decided_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    -- Tasks table (workflow tracking)
    CREATE TABLE IF NOT EXISTS tasks (
        id INTEGER PRIMARY KEY,
        assessment_id INTEGER REFERENCES assessments(id),
        title TEXT NOT NULL,
        description TEXT,
        status TEXT DEFAULT 'pending',
        priority TEXT DEFAULT 'medium',
        phase TEXT,
        notes TEXT,
        findings JSON,
        blocked_by JSON,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP,
        completed_at TIMESTAMP
    );

    -- Indexes for performance
    CREATE INDEX IF NOT EXISTS idx_findings_assessment ON findings(assessment_id);
    CREATE INDEX IF NOT EXISTS idx_findings_severity ON findings(severity);
    CREATE INDEX IF NOT EXISTS idx_access_assessment ON access_levels(assessment_id);
    CREATE INDEX IF NOT EXISTS idx_tools_assessment ON tool_executions(assessment_id);
    CREATE INDEX IF NOT EXISTS idx_decisions_assessment ON decisions(assessment_id);
    CREATE INDEX IF NOT EXISTS idx_assets_assessment ON assets(assessment_id);
    CREATE INDEX IF NOT EXISTS idx_tasks_assessment ON tasks(assessment_id);
    CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
    """

    def __init__(self, db_path: str = None):
        """Initialize state manager with database path."""
        if db_path is None:
            import os
            data_dir = Path(os.environ.get('BLACKBOX_DATA_DIR', Path.home() / '.blackbox' / 'pentest'))
            data_dir.mkdir(parents=True, exist_ok=True)
            db_path = str(data_dir / "state.db")
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self._init_db()

    def _init_db(self):
        """Initialize database schema."""
        with self._get_connection() as conn:
            conn.executescript(self.SCHEMA)

    @contextmanager
    def _get_connection(self):
        """Get database connection with context management."""
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()

    # Assessment Management

    def create_assessment(self, target: str, domain: Optional[str] = None,
                          config: Optional[Dict[str, Any]] = None) -> int:
        """Create a new assessment and return its ID."""
        with self._get_connection() as conn:
            cursor = conn.execute(
                """INSERT INTO assessments (target, domain, config)
                   VALUES (?, ?, ?)""",
                (target, domain, json.dumps(config or {}))
            )
            return cursor.lastrowid

    def get_assessment(self, assessment_id: int) -> Optional[Dict[str, Any]]:
        """Get assessment by ID."""
        with self._get_connection() as conn:
            row = conn.execute(
                "SELECT * FROM assessments WHERE id = ?",
                (assessment_id,)
            ).fetchone()
            if row:
                return dict(row)
            return None

    def get_assessment_by_target(self, target: str,
                                  status: str = 'active') -> Optional[Dict[str, Any]]:
        """Get assessment by target and status."""
        with self._get_connection() as conn:
            row = conn.execute(
                """SELECT * FROM assessments
                   WHERE target = ? AND status = ?
                   ORDER BY started_at DESC LIMIT 1""",
                (target, status)
            ).fetchone()
            if row:
                return dict(row)
            return None

    def update_assessment(self, assessment_id: int, **updates) -> None:
        """Update assessment fields."""
        allowed_fields = {'status', 'current_phase', 'config', 'completed_at'}
        updates = {k: v for k, v in updates.items() if k in allowed_fields}

        if not updates:
            return

        if 'config' in updates:
            updates['config'] = json.dumps(updates['config'])

        updates['updated_at'] = datetime.now().isoformat()

        set_clause = ', '.join(f"{k} = ?" for k in updates.keys())
        values = list(updates.values()) + [assessment_id]

        with self._get_connection() as conn:
            conn.execute(
                f"UPDATE assessments SET {set_clause} WHERE id = ?",
                values
            )

    def complete_assessment(self, assessment_id: int) -> None:
        """Mark assessment as complete."""
        self.update_assessment(
            assessment_id,
            status='complete',
            completed_at=datetime.now().isoformat()
        )

    # Finding Management

    def save_finding(self, assessment_id: int, finding: Finding) -> int:
        """Persist finding and return its ID."""
        with self._get_connection() as conn:
            cursor = conn.execute(
                """INSERT INTO findings
                   (assessment_id, phase, tool, type, severity, title,
                    description, evidence, cvss_score, cve_ids,
                    mitre_techniques, remediation)
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    assessment_id,
                    finding.phase,
                    finding.tool,
                    finding.type.value if isinstance(finding.type, FindingType) else finding.type,
                    finding.severity.value if isinstance(finding.severity, Severity) else finding.severity,
                    finding.title,
                    finding.description,
                    json.dumps(finding.evidence),
                    finding.cvss_score,
                    json.dumps(finding.cve_ids),
                    json.dumps(finding.mitre_techniques),
                    finding.remediation
                )
            )
            return cursor.lastrowid

    def get_findings(self, assessment_id: int,
                     severity: Optional[str] = None,
                     finding_type: Optional[str] = None) -> List[Finding]:
        """Get findings for an assessment with optional filters."""
        query = "SELECT * FROM findings WHERE assessment_id = ?"
        params = [assessment_id]

        if severity:
            query += " AND severity = ?"
            params.append(severity)

        if finding_type:
            query += " AND type = ?"
            params.append(finding_type)

        query += " ORDER BY discovered_at DESC"

        with self._get_connection() as conn:
            rows = conn.execute(query, params).fetchall()
            return [self._row_to_finding(row) for row in rows]

    def get_finding_counts(self, assessment_id: int) -> Dict[str, int]:
        """Get counts of findings by severity."""
        with self._get_connection() as conn:
            rows = conn.execute(
                """SELECT severity, COUNT(*) as count
                   FROM findings WHERE assessment_id = ?
                   GROUP BY severity""",
                (assessment_id,)
            ).fetchall()
            return {row['severity']: row['count'] for row in rows}

    def _row_to_finding(self, row: sqlite3.Row) -> Finding:
        """Convert database row to Finding object."""
        return Finding(
            id=row['id'],
            assessment_id=row['assessment_id'],
            phase=row['phase'],
            tool=row['tool'],
            type=FindingType(row['type']) if row['type'] else None,
            severity=Severity(row['severity']) if row['severity'] else None,
            title=row['title'],
            description=row['description'],
            evidence=json.loads(row['evidence']) if row['evidence'] else {},
            cvss_score=row['cvss_score'],
            cve_ids=json.loads(row['cve_ids']) if row['cve_ids'] else [],
            mitre_techniques=json.loads(row['mitre_techniques']) if row['mitre_techniques'] else [],
            remediation=row['remediation'],
            discovered_at=datetime.fromisoformat(row['discovered_at']) if row['discovered_at'] else None
        )

    # Access Level Management

    def save_access_level(self, assessment_id: int, access: AccessRecord) -> int:
        """Save access level achievement."""
        level_str = access.level.name if isinstance(access.level, AccessLevel) else access.level

        with self._get_connection() as conn:
            cursor = conn.execute(
                """INSERT INTO access_levels
                   (assessment_id, level, context, credentials)
                   VALUES (?, ?, ?, ?)""",
                (
                    assessment_id,
                    level_str,
                    access.context,
                    json.dumps(access.credentials)
                )
            )
            return cursor.lastrowid

    def get_highest_access(self, assessment_id: int) -> Optional[AccessLevel]:
        """Get highest access level achieved."""
        with self._get_connection() as conn:
            rows = conn.execute(
                "SELECT level FROM access_levels WHERE assessment_id = ?",
                (assessment_id,)
            ).fetchall()

            if not rows:
                return AccessLevel.ANONYMOUS

            levels = [AccessLevel[row['level']] for row in rows]
            return max(levels, key=lambda x: x.value)

    def get_access_records(self, assessment_id: int) -> List[AccessRecord]:
        """Get all access records for an assessment."""
        with self._get_connection() as conn:
            rows = conn.execute(
                "SELECT * FROM access_levels WHERE assessment_id = ? ORDER BY achieved_at",
                (assessment_id,)
            ).fetchall()
            return [
                AccessRecord(
                    id=row['id'],
                    assessment_id=row['assessment_id'],
                    level=AccessLevel[row['level']],
                    context=row['context'],
                    credentials=json.loads(row['credentials']) if row['credentials'] else {},
                    achieved_at=datetime.fromisoformat(row['achieved_at']) if row['achieved_at'] else None
                )
                for row in rows
            ]

    # Asset Management

    def save_asset(self, assessment_id: int, asset: Asset) -> int:
        """Save acquired asset."""
        asset_type = asset.type.value if isinstance(asset.type, AssetType) else asset.type

        with self._get_connection() as conn:
            cursor = conn.execute(
                """INSERT INTO assets
                   (assessment_id, type, name, location, content_hash, metadata)
                   VALUES (?, ?, ?, ?, ?, ?)""",
                (
                    assessment_id,
                    asset_type,
                    asset.name,
                    asset.location,
                    asset.content_hash,
                    json.dumps(asset.metadata)
                )
            )
            return cursor.lastrowid

    def get_assets(self, assessment_id: int,
                   asset_type: Optional[str] = None) -> List[Asset]:
        """Get assets for an assessment."""
        query = "SELECT * FROM assets WHERE assessment_id = ?"
        params = [assessment_id]

        if asset_type:
            query += " AND type = ?"
            params.append(asset_type)

        with self._get_connection() as conn:
            rows = conn.execute(query, params).fetchall()
            return [
                Asset(
                    id=row['id'],
                    assessment_id=row['assessment_id'],
                    type=AssetType(row['type']) if row['type'] else None,
                    name=row['name'],
                    location=row['location'],
                    content_hash=row['content_hash'],
                    metadata=json.loads(row['metadata']) if row['metadata'] else {},
                    acquired_at=datetime.fromisoformat(row['acquired_at']) if row['acquired_at'] else None
                )
                for row in rows
            ]

    def has_asset_type(self, assessment_id: int, asset_type: AssetType) -> bool:
        """Check if a specific asset type has been acquired."""
        type_str = asset_type.value if isinstance(asset_type, AssetType) else asset_type
        with self._get_connection() as conn:
            row = conn.execute(
                "SELECT COUNT(*) as count FROM assets WHERE assessment_id = ? AND type = ?",
                (assessment_id, type_str)
            ).fetchone()
            return row['count'] > 0

    # Tool Execution Logging

    def log_tool_execution(self, assessment_id: int, execution: ToolExecution) -> int:
        """Log tool execution for audit trail."""
        with self._get_connection() as conn:
            cursor = conn.execute(
                """INSERT INTO tool_executions
                   (assessment_id, phase, tool, params, result, duration_ms)
                   VALUES (?, ?, ?, ?, ?, ?)""",
                (
                    assessment_id,
                    execution.phase,
                    execution.tool,
                    json.dumps(execution.params),
                    json.dumps(execution.result),
                    execution.duration_ms
                )
            )
            return cursor.lastrowid

    def get_tool_executions(self, assessment_id: int,
                            tool: Optional[str] = None) -> List[ToolExecution]:
        """Get tool executions for an assessment."""
        query = "SELECT * FROM tool_executions WHERE assessment_id = ?"
        params = [assessment_id]

        if tool:
            query += " AND tool = ?"
            params.append(tool)

        query += " ORDER BY executed_at DESC"

        with self._get_connection() as conn:
            rows = conn.execute(query, params).fetchall()
            return [
                ToolExecution(
                    id=row['id'],
                    assessment_id=row['assessment_id'],
                    phase=row['phase'],
                    tool=row['tool'],
                    params=json.loads(row['params']) if row['params'] else {},
                    result=json.loads(row['result']) if row['result'] else {},
                    duration_ms=row['duration_ms'],
                    executed_at=datetime.fromisoformat(row['executed_at']) if row['executed_at'] else None
                )
                for row in rows
            ]

    # Decision Logging

    def log_decision(self, assessment_id: int, decision: Decision) -> int:
        """Log decision for audit trail."""
        with self._get_connection() as conn:
            cursor = conn.execute(
                """INSERT INTO decisions
                   (assessment_id, rule_name, condition_met, action_taken,
                    context_before, context_after)
                   VALUES (?, ?, ?, ?, ?, ?)""",
                (
                    assessment_id,
                    decision.rule_name,
                    decision.condition_met,
                    decision.action_taken,
                    json.dumps(decision.context_before),
                    json.dumps(decision.context_after)
                )
            )
            return cursor.lastrowid

    def get_decisions(self, assessment_id: int) -> List[Decision]:
        """Get all decisions for an assessment."""
        with self._get_connection() as conn:
            rows = conn.execute(
                "SELECT * FROM decisions WHERE assessment_id = ? ORDER BY decided_at",
                (assessment_id,)
            ).fetchall()
            return [
                Decision(
                    id=row['id'],
                    assessment_id=row['assessment_id'],
                    rule_name=row['rule_name'],
                    condition_met=row['condition_met'],
                    action_taken=row['action_taken'],
                    context_before=json.loads(row['context_before']) if row['context_before'] else {},
                    context_after=json.loads(row['context_after']) if row['context_after'] else {},
                    decided_at=datetime.fromisoformat(row['decided_at']) if row['decided_at'] else None
                )
                for row in rows
            ]

    # Full State Reconstruction

    def get_assessment_state(self, target: str) -> Optional[AssessmentState]:
        """Reconstruct full assessment state for resume capability."""
        assessment = self.get_assessment_by_target(target)
        if not assessment:
            return None

        assessment_id = assessment['id']

        return AssessmentState(
            id=assessment_id,
            target=assessment['target'],
            domain=assessment['domain'],
            status=assessment['status'],
            current_phase=assessment['current_phase'],
            config=json.loads(assessment['config']) if assessment['config'] else {},
            started_at=datetime.fromisoformat(assessment['started_at']) if assessment['started_at'] else None,
            updated_at=datetime.fromisoformat(assessment['updated_at']) if assessment['updated_at'] else None,
            completed_at=datetime.fromisoformat(assessment['completed_at']) if assessment['completed_at'] else None,
            findings=self.get_findings(assessment_id),
            access_levels=self.get_access_records(assessment_id),
            assets=self.get_assets(assessment_id),
            tool_executions=self.get_tool_executions(assessment_id),
            decisions=self.get_decisions(assessment_id)
        )

    # Export Functionality

    def export_json(self, assessment_id: int, path: str) -> None:
        """Export assessment to portable JSON format."""
        assessment = self.get_assessment(assessment_id)
        if not assessment:
            raise ValueError(f"Assessment {assessment_id} not found")

        state = AssessmentState(
            id=assessment_id,
            target=assessment['target'],
            domain=assessment['domain'],
            status=assessment['status'],
            current_phase=assessment['current_phase'],
            config=json.loads(assessment['config']) if assessment['config'] else {},
            started_at=datetime.fromisoformat(assessment['started_at']) if assessment['started_at'] else None,
            updated_at=datetime.fromisoformat(assessment['updated_at']) if assessment['updated_at'] else None,
            completed_at=datetime.fromisoformat(assessment['completed_at']) if assessment['completed_at'] else None,
            findings=self.get_findings(assessment_id),
            access_levels=self.get_access_records(assessment_id),
            assets=self.get_assets(assessment_id),
            tool_executions=self.get_tool_executions(assessment_id),
            decisions=self.get_decisions(assessment_id)
        )

        # Convert to JSON-serializable format
        def serialize(obj):
            if isinstance(obj, datetime):
                return obj.isoformat()
            elif isinstance(obj, Enum):
                return obj.value
            elif hasattr(obj, '__dict__'):
                return {k: serialize(v) for k, v in obj.__dict__.items()}
            elif isinstance(obj, list):
                return [serialize(i) for i in obj]
            elif isinstance(obj, dict):
                return {k: serialize(v) for k, v in obj.items()}
            return obj

        export_data = serialize(state)

        with open(path, 'w') as f:
            json.dump(export_data, f, indent=2)

    def import_json(self, path: str) -> int:
        """Import assessment from JSON and return new assessment ID."""
        with open(path, 'r') as f:
            data = json.load(f)

        # Create new assessment
        assessment_id = self.create_assessment(
            target=data['target'],
            domain=data.get('domain'),
            config=data.get('config', {})
        )

        # Import findings
        for finding_data in data.get('findings', []):
            finding = Finding(
                phase=finding_data['phase'],
                tool=finding_data['tool'],
                type=FindingType(finding_data['type']) if finding_data.get('type') else FindingType.INFO,
                severity=Severity(finding_data['severity']) if finding_data.get('severity') else Severity.INFO,
                title=finding_data['title'],
                description=finding_data['description'],
                evidence=finding_data.get('evidence', {}),
                cvss_score=finding_data.get('cvss_score'),
                cve_ids=finding_data.get('cve_ids', []),
                mitre_techniques=finding_data.get('mitre_techniques', []),
                remediation=finding_data.get('remediation')
            )
            self.save_finding(assessment_id, finding)

        # Import access levels
        for access_data in data.get('access_levels', []):
            access = AccessRecord(
                level=AccessLevel[access_data['level']] if isinstance(access_data['level'], str) else AccessLevel(access_data['level']),
                context=access_data['context'],
                credentials=access_data.get('credentials', {})
            )
            self.save_access_level(assessment_id, access)

        # Import assets
        for asset_data in data.get('assets', []):
            asset = Asset(
                type=AssetType(asset_data['type']) if asset_data.get('type') else AssetType.CONFIG,
                name=asset_data['name'],
                location=asset_data['location'],
                metadata=asset_data.get('metadata', {}),
                content_hash=asset_data.get('content_hash')
            )
            self.save_asset(assessment_id, asset)

        return assessment_id

    # Utility Methods

    def compute_content_hash(self, content: bytes) -> str:
        """Compute SHA-256 hash of content."""
        return hashlib.sha256(content).hexdigest()

    def get_all_assessments(self, status: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get all assessments, optionally filtered by status."""
        query = "SELECT * FROM assessments"
        params = []

        if status:
            query += " WHERE status = ?"
            params.append(status)

        query += " ORDER BY started_at DESC"

        with self._get_connection() as conn:
            rows = conn.execute(query, params).fetchall()
            return [dict(row) for row in rows]

    def delete_assessment(self, assessment_id: int) -> None:
        """Delete an assessment and all related records."""
        with self._get_connection() as conn:
            # Delete related records first
            conn.execute("DELETE FROM findings WHERE assessment_id = ?", (assessment_id,))
            conn.execute("DELETE FROM access_levels WHERE assessment_id = ?", (assessment_id,))
            conn.execute("DELETE FROM assets WHERE assessment_id = ?", (assessment_id,))
            conn.execute("DELETE FROM tool_executions WHERE assessment_id = ?", (assessment_id,))
            conn.execute("DELETE FROM decisions WHERE assessment_id = ?", (assessment_id,))
            conn.execute("DELETE FROM tasks WHERE assessment_id = ?", (assessment_id,))
            # Delete assessment
            conn.execute("DELETE FROM assessments WHERE id = ?", (assessment_id,))

    # Task Management

    def create_task(self, assessment_id: int, task: Task) -> int:
        """Create a new task and return its ID."""
        status_str = task.status.value if isinstance(task.status, TaskStatus) else task.status
        priority_str = task.priority.value if isinstance(task.priority, TaskPriority) else task.priority

        with self._get_connection() as conn:
            cursor = conn.execute(
                """INSERT INTO tasks
                   (assessment_id, title, description, status, priority, phase, notes, findings, blocked_by)
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    assessment_id,
                    task.title,
                    task.description,
                    status_str,
                    priority_str,
                    task.phase,
                    task.notes,
                    json.dumps(task.findings),
                    json.dumps(task.blocked_by)
                )
            )
            return cursor.lastrowid

    def update_task(self, task_id: int, **updates) -> None:
        """Update task fields."""
        allowed_fields = {'title', 'description', 'status', 'priority', 'phase', 'notes', 'findings', 'blocked_by', 'completed_at'}
        updates = {k: v for k, v in updates.items() if k in allowed_fields}

        if not updates:
            return

        # Convert enums and lists
        if 'status' in updates and isinstance(updates['status'], TaskStatus):
            updates['status'] = updates['status'].value
        if 'priority' in updates and isinstance(updates['priority'], TaskPriority):
            updates['priority'] = updates['priority'].value
        if 'findings' in updates:
            updates['findings'] = json.dumps(updates['findings'])
        if 'blocked_by' in updates:
            updates['blocked_by'] = json.dumps(updates['blocked_by'])

        updates['updated_at'] = datetime.now().isoformat()

        set_clause = ', '.join(f"{k} = ?" for k in updates.keys())
        values = list(updates.values()) + [task_id]

        with self._get_connection() as conn:
            conn.execute(
                f"UPDATE tasks SET {set_clause} WHERE id = ?",
                values
            )

    def complete_task(self, task_id: int, findings: Optional[List[str]] = None) -> None:
        """Mark task as complete with optional findings."""
        updates = {
            'status': 'completed',
            'completed_at': datetime.now().isoformat()
        }
        if findings:
            updates['findings'] = findings
        self.update_task(task_id, **updates)

    def get_task(self, task_id: int) -> Optional[Task]:
        """Get task by ID."""
        with self._get_connection() as conn:
            row = conn.execute(
                "SELECT * FROM tasks WHERE id = ?",
                (task_id,)
            ).fetchone()
            if row:
                return self._row_to_task(row)
            return None

    def get_tasks(self, assessment_id: int, status: Optional[str] = None) -> List[Task]:
        """Get tasks for an assessment with optional status filter."""
        query = "SELECT * FROM tasks WHERE assessment_id = ?"
        params = [assessment_id]

        if status:
            query += " AND status = ?"
            params.append(status)

        query += " ORDER BY CASE priority WHEN 'critical' THEN 1 WHEN 'high' THEN 2 WHEN 'medium' THEN 3 WHEN 'low' THEN 4 END, created_at"

        with self._get_connection() as conn:
            rows = conn.execute(query, params).fetchall()
            return [self._row_to_task(row) for row in rows]

    def get_next_task(self, assessment_id: int) -> Optional[Task]:
        """Get the next pending task by priority."""
        tasks = self.get_tasks(assessment_id, status='pending')
        for task in tasks:
            # Check if blocked
            if not task.blocked_by:
                return task
            # Check if blockers are complete
            all_complete = True
            for blocker_id in task.blocked_by:
                blocker = self.get_task(blocker_id)
                if blocker and blocker.status != TaskStatus.COMPLETED:
                    all_complete = False
                    break
            if all_complete:
                return task
        return None

    def _row_to_task(self, row: sqlite3.Row) -> Task:
        """Convert database row to Task object."""
        return Task(
            id=row['id'],
            assessment_id=row['assessment_id'],
            title=row['title'],
            description=row['description'],
            status=TaskStatus(row['status']) if row['status'] else TaskStatus.PENDING,
            priority=TaskPriority(row['priority']) if row['priority'] else TaskPriority.MEDIUM,
            phase=row['phase'],
            notes=row['notes'],
            findings=json.loads(row['findings']) if row['findings'] else [],
            blocked_by=json.loads(row['blocked_by']) if row['blocked_by'] else [],
            created_at=datetime.fromisoformat(row['created_at']) if row['created_at'] else None,
            updated_at=datetime.fromisoformat(row['updated_at']) if row['updated_at'] else None,
            completed_at=datetime.fromisoformat(row['completed_at']) if row['completed_at'] else None
        )
