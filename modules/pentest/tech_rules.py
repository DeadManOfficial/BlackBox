"""
Technology-Specific Rules for DeadMan Pen.

Rules that trigger based on detected technologies.
Dynamically adapts to whatever tech stack is discovered.
"""

from typing import List, Union
from dataclasses import dataclass, field


@dataclass
class ToolExecution:
    """Tool to execute."""
    tool: str
    params: dict = field(default_factory=dict)
    priority: int = 50
    timeout: int = None


@dataclass
class ConditionalTool:
    """Conditional tool execution."""
    condition: callable
    tool: str
    params: dict = field(default_factory=dict)
    action: callable = None


@dataclass
class ToolChain:
    """Chain of tools to execute."""
    tools: list = field(default_factory=list)

    def resolve(self, results: dict) -> List[ToolExecution]:
        resolved = []
        for item in self.tools:
            if isinstance(item, ToolExecution):
                resolved.append(item)
            elif isinstance(item, ConditionalTool):
                if item.condition(results):
                    resolved.append(ToolExecution(tool=item.tool, params=item.params))
        return resolved


# =============================================================================
# Backend Technology Rules (BaaS, Serverless, Direct Access)
# =============================================================================

def baas_detected(ctx) -> ToolChain:
    """
    IF any Backend-as-a-Service detected (Supabase, Firebase, Appwrite, etc.)
    THEN test for direct access vulnerabilities
    """
    tools = []

    # Generic backend access testing
    if hasattr(ctx, 'supabase_url') and ctx.supabase_url:
        tools.append(ToolExecution('backend_access_scan', {
            'service': 'supabase',
            'url': ctx.supabase_url,
            'anon_key': ctx.extracted_keys.get('supabase_anon')
        }))
        tools.append(ConditionalTool(
            condition=lambda r: r.get('anon_key_valid'),
            tool='db_error_exploit',
            params={'dbType': 'postgres'}
        ))

    if hasattr(ctx, 'firebase_project') and ctx.firebase_project:
        tools.append(ToolExecution('backend_access_scan', {
            'service': 'firebase',
            'project_id': ctx.firebase_project
        }))

    # Storage enumeration for any detected backend
    tools.append(ToolExecution('cloud_storage_enum', {'provider': 'auto'}))

    return ToolChain(tools=tools)


def database_detected(ctx) -> ToolChain:
    """
    IF database technology detected (Postgres, MySQL, MongoDB, etc.)
    THEN test for injection and error-based extraction
    """
    tools = []

    # Generic database testing
    tools.append(ToolExecution('db_error_exploit', {
        'dbType': 'auto',  # Auto-detect
    }))

    # GraphQL often means database access
    if ctx.has_technology('graphql') or hasattr(ctx, 'graphql_endpoint'):
        tools.append(ToolExecution('graphql_scan', {
            'graphqlUrl': getattr(ctx, 'graphql_endpoint', ctx.target_url),
            'testIntrospection': True,
            'testBatching': True
        }))

    return ToolChain(tools=tools)


# =============================================================================
# Authentication Technology Rules
# =============================================================================

def oauth_detected(ctx) -> ToolChain:
    """
    IF OAuth/OIDC detected
    THEN test for OAuth flow vulnerabilities
    """
    tools = []

    if ctx.oauth_endpoints:
        for endpoint in ctx.oauth_endpoints[:3]:  # Limit to 3
            tools.append(ToolExecution('oauth_scan', {
                'authUrl': endpoint,
                'categories': ['open_redirect', 'state_fixation', 'token_leakage', 'pkce_bypass']
            }))

    return ToolChain(tools=tools)


def jwt_detected(ctx) -> ToolChain:
    """
    IF JWT tokens detected
    THEN test for JWT vulnerabilities
    """
    tools = []

    for token in ctx.jwt_tokens[:3]:  # Limit to 3
        tools.append(ToolExecution('jwt_analyze', {
            'token': token,
            'testNoneAlg': True,
            'testAlgConfusion': True
        }))

    return ToolChain(tools=tools)


def session_detected(ctx) -> ToolChain:
    """
    IF session management detected
    THEN test for session vulnerabilities
    """
    tools = []

    # CORS + auth exploitation
    tools.append(ToolExecution('cors_auth_scan', {
        'url': ctx.target_url,
        'auth_token': ctx.jwt_tokens[0] if ctx.jwt_tokens else None
    }))

    # Race conditions on session
    tools.append(ToolExecution('race_condition_scan', {
        'url': ctx.target_url,
    }))

    return ToolChain(tools=tools)


# =============================================================================
# Payment Technology Rules
# =============================================================================

def payment_detected(ctx) -> ToolChain:
    """
    IF payment system detected (Stripe, PayPal, Paddle, etc.)
    THEN comprehensive payment security testing
    """
    tools = []

    checkout_url = getattr(ctx, 'checkout_endpoint', None) or ctx.target_url

    tools.append(ToolExecution('payment_injection_scan', {
        'url': checkout_url,
        'base_payload': getattr(ctx, 'observed_checkout_payload', {})
    }))

    tools.append(ToolExecution('payment_security_test', {
        'url': checkout_url,
        'categories': ['negative_value', 'currency_confusion', 'quantity_manipulation', 'trial_extension']
    }))

    # Webhook testing if endpoint found
    webhook_url = getattr(ctx, 'webhook_endpoint', None)
    if webhook_url:
        tools.append(ToolExecution('payment_webhook_test', {
            'url': webhook_url
        }))

    return ToolChain(tools=tools)


# =============================================================================
# AI/ML Technology Rules
# =============================================================================

def ai_detected(ctx) -> ToolChain:
    """
    IF AI/LLM endpoint detected
    THEN comprehensive AI security assessment
    """
    tools = []

    for endpoint in ctx.ai_endpoints[:2]:
        # Phase 1: Quick direct tests
        tools.append(ToolExecution('ai_security_test', {
            'url': endpoint,
            'categories': ['prompt_injection', 'jailbreak', 'system_prompt_leak']
        }))

        # Phase 2: Advanced testing
        tools.append(ToolExecution('llm_redteam_scan', {
            'targetUrl': endpoint,
            'strategies': ['direct', 'multi_turn', 'encoding', 'roleplay']
        }))

        # Phase 3: Indirect injection
        tools.append(ConditionalTool(
            condition=lambda r: r.get('agent_detected') or r.get('tools_exposed'),
            tool='indirect_injection_test',
            params={'targetUrl': endpoint, 'method': 'tool_manipulation'}
        ))

        # Phase 4: Crescendo if resistant
        tools.append(ConditionalTool(
            condition=lambda r: r.get('resistance_detected'),
            tool='crescendo_attack',
            params={'targetUrl': endpoint, 'goal': 'extract system prompt', 'maxTurns': 20}
        ))

    return ToolChain(tools=tools)


# =============================================================================
# Web Framework Rules
# =============================================================================

def frontend_framework_detected(ctx) -> ToolChain:
    """
    IF frontend framework detected (React, Vue, Angular, etc.)
    THEN analyze JS bundles for secrets and source maps
    """
    tools = []

    # JS analysis
    if ctx.js_bundles:
        tools.append(ToolExecution('js_analyze_batch', {
            'urls': ctx.js_bundles
        }))

    # API enumeration for typical patterns
    tools.append(ToolExecution('api_enumerate', {
        'baseUrl': ctx.target_url,
        'wordlist': 'common',
        'detectVersions': True
    }))

    return ToolChain(tools=tools)


def api_detected(ctx) -> ToolChain:
    """
    IF API endpoints detected
    THEN comprehensive API security testing
    """
    tools = []

    base_url = getattr(ctx, 'api_base', ctx.target_url)

    # API enumeration
    tools.append(ToolExecution('api_enumerate', {
        'baseUrl': base_url,
        'wordlist': 'common',
        'detectVersions': True
    }))

    # CORS testing
    tools.append(ToolExecution('cors_scan', {
        'targetUrl': base_url,
        'testNullOrigin': True,
        'testSubdomain': True
    }))

    # Rate limiting / race conditions
    tools.append(ToolExecution('race_condition_scan', {
        'url': base_url
    }))

    return ToolChain(tools=tools)


def graphql_detected(ctx) -> ToolChain:
    """
    IF GraphQL detected
    THEN GraphQL-specific testing
    """
    tools = []

    endpoint = getattr(ctx, 'graphql_endpoint', ctx.target_url)

    tools.append(ToolExecution('graphql_scan', {
        'graphqlUrl': endpoint,
        'testIntrospection': True,
        'testBatching': True
    }))

    return ToolChain(tools=tools)


# =============================================================================
# Cloud Infrastructure Rules
# =============================================================================

def cloud_detected(ctx) -> ToolChain:
    """
    IF cloud infrastructure detected (AWS, GCP, Azure)
    THEN test for cloud-specific vulnerabilities
    """
    tools = []

    # SSRF for cloud metadata
    tools.append(ToolExecution('ssrf_scan', {
        'targetUrl': ctx.target_url,
        'param': 'url',
        'clouds': ['aws', 'gcp', 'azure']
    }))

    # Storage enumeration
    tools.append(ToolExecution('cloud_storage_enum', {
        'provider': 'auto'
    }))

    # Subdomain takeover
    if ctx.subdomains:
        tools.append(ToolExecution('subdomain_takeover_scan', {
            'subdomains': ctx.subdomains,
            'services': ['aws_s3', 'github_pages', 'heroku', 'azure', 'netlify', 'vercel']
        }))

    return ToolChain(tools=tools)


# =============================================================================
# Web Application Rules
# =============================================================================

def web_app_detected(ctx) -> ToolChain:
    """
    General web application testing - always runs.
    """
    tools = []

    # CORS
    tools.append(ToolExecution('cors_scan', {
        'targetUrl': ctx.target_url,
        'testNullOrigin': True,
        'testSubdomain': True
    }))

    # Path traversal
    tools.append(ToolExecution('path_traversal_scan', {
        'targetUrl': ctx.target_url,
        'param': 'file',
        'depth': 10
    }))

    # Host header
    tools.append(ToolExecution('host_header_scan', {
        'targetUrl': ctx.target_url,
        'testPasswordReset': True
    }))

    # CRLF
    tools.append(ToolExecution('crlf_scan', {
        'targetUrl': ctx.target_url,
        'testResponseSplitting': True
    }))

    return ToolChain(tools=tools)


def form_detected(ctx) -> ToolChain:
    """
    IF forms detected
    THEN test for injection vulnerabilities
    """
    tools = []

    # SSTI
    tools.append(ToolExecution('ssti_scan', {
        'targetUrl': ctx.target_url,
        'param': 'template',
        'engines': ['jinja2', 'twig', 'freemarker', 'velocity']
    }))

    # Command injection
    tools.append(ToolExecution('command_injection_scan', {
        'targetUrl': ctx.target_url,
        'param': 'cmd',
        'testTimeBased': True
    }))

    # XXE
    tools.append(ToolExecution('xxe_scan', {
        'targetUrl': ctx.target_url,
        'testFileRead': True,
        'testSSRF': True
    }))

    return ToolChain(tools=tools)


# =============================================================================
# Network/Infrastructure Rules
# =============================================================================

def waf_detected(ctx) -> ToolChain:
    """
    IF WAF/CDN detected
    THEN attempt bypass
    """
    tools = []

    tools.append(ToolExecution('waf_bypass_scan', {
        'domain': ctx.domain or ctx.target
    }))

    return ToolChain(tools=tools)


def websocket_detected(ctx) -> ToolChain:
    """
    IF WebSocket detected
    THEN WebSocket security testing
    """
    tools = []

    ws_url = getattr(ctx, 'websocket_url', None)
    if ws_url:
        tools.append(ToolExecution('websocket_scan', {
            'websocketUrl': ws_url,
            'testCswsh': True,
            'testInjection': True
        }))

    return ToolChain(tools=tools)


# =============================================================================
# Dynamic Technology Mapping
# =============================================================================

# Maps technology names to their rule functions
TECH_RULE_MAPPING = {
    # Backend
    'supabase': baas_detected,
    'firebase': baas_detected,
    'appwrite': baas_detected,
    'parse': baas_detected,

    # Databases
    'postgresql': database_detected,
    'postgres': database_detected,
    'mysql': database_detected,
    'mongodb': database_detected,
    'redis': database_detected,

    # Auth
    'oauth': oauth_detected,
    'auth0': oauth_detected,
    'clerk': oauth_detected,
    'keycloak': oauth_detected,

    # Payment
    'stripe': payment_detected,
    'paypal': payment_detected,
    'paddle': payment_detected,
    'braintree': payment_detected,

    # AI
    'openai': ai_detected,
    'anthropic': ai_detected,
    'huggingface': ai_detected,
    'langchain': ai_detected,

    # Frontend
    'react': frontend_framework_detected,
    'vue': frontend_framework_detected,
    'angular': frontend_framework_detected,
    'svelte': frontend_framework_detected,
    'nextjs': frontend_framework_detected,
    'nuxt': frontend_framework_detected,

    # API
    'graphql': graphql_detected,
    'rest': api_detected,
    'grpc': api_detected,

    # Cloud
    'aws': cloud_detected,
    'gcp': cloud_detected,
    'azure': cloud_detected,
    'vercel': cloud_detected,
    'netlify': cloud_detected,

    # Infrastructure
    'cloudflare': waf_detected,
    'akamai': waf_detected,
}


def get_rules_for_tech(tech_name: str):
    """Get rule function for a technology."""
    return TECH_RULE_MAPPING.get(tech_name.lower())


def evaluate_all_tech_rules(ctx) -> List[ToolExecution]:
    """
    Evaluate all applicable tech rules for current context.
    Returns combined list of tools to execute.
    """
    all_tools = []

    # Always run web app rules
    web_chain = web_app_detected(ctx)
    all_tools.extend(web_chain.tools)

    # Run rules for each detected technology
    if hasattr(ctx, 'tech_stack') and ctx.tech_stack:
        for tech in ctx.tech_stack:
            rule_fn = get_rules_for_tech(tech.name)
            if rule_fn:
                chain = rule_fn(ctx)
                all_tools.extend(chain.tools)

    # Check for specific detections
    if ctx.jwt_tokens:
        chain = jwt_detected(ctx)
        all_tools.extend(chain.tools)

    if ctx.oauth_endpoints:
        chain = oauth_detected(ctx)
        all_tools.extend(chain.tools)

    if ctx.ai_endpoints:
        chain = ai_detected(ctx)
        all_tools.extend(chain.tools)

    if getattr(ctx, 'checkout_endpoint', None):
        chain = payment_detected(ctx)
        all_tools.extend(chain.tools)

    # Deduplicate
    seen = set()
    unique_tools = []
    for tool in all_tools:
        if isinstance(tool, ToolExecution):
            key = (tool.tool, str(tool.params))
            if key not in seen:
                seen.add(key)
                unique_tools.append(tool)
        else:
            unique_tools.append(tool)

    return unique_tools
