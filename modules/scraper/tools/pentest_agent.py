"""
Autonomous Penetration Testing Agent
=====================================

PentestGPT-style autonomous security testing with reasoning, generation, and parsing.
Implements MCTS-based attack path planning and autonomous exploit chains.

Author: DeadManOfficial
Version: 2.0.0 (2026 Edition)
"""

from __future__ import annotations

import asyncio
import json
import subprocess
import shutil
import re
import random
import math
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Awaitable, Tuple, Set
import logging

logger = logging.getLogger(__name__)


# =============================================================================
# ENUMS AND CONSTANTS
# =============================================================================

class AttackPhase(Enum):
    """Penetration testing phases"""
    RECONNAISSANCE = "recon"
    SCANNING = "scanning"
    ENUMERATION = "enumeration"
    VULNERABILITY_ANALYSIS = "vuln_analysis"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploit"
    REPORTING = "reporting"


class ToolCategory(Enum):
    """Security tool categories"""
    NETWORK = "network"
    WEB = "web"
    OSINT = "osint"
    EXPLOITATION = "exploit"
    PASSWORD = "password"
    WIRELESS = "wireless"
    FORENSICS = "forensics"


class Severity(Enum):
    CRITICAL = 5
    HIGH = 4
    MEDIUM = 3
    LOW = 2
    INFO = 1


# =============================================================================
# DATA CLASSES
# =============================================================================

@dataclass
class Target:
    """Target information"""
    host: str
    port: int = 0
    protocol: str = "tcp"
    service: str = ""
    version: str = ""
    os: str = ""
    vulnerabilities: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Tool:
    """Security tool definition"""
    name: str
    category: ToolCategory
    command: str
    args_template: str
    output_parser: Callable[[str], Dict]
    description: str
    requires_root: bool = False
    timeout: int = 300


@dataclass
class AttackStep:
    """Single attack step"""
    id: str
    phase: AttackPhase
    tool: str
    command: str
    description: str
    preconditions: List[str] = field(default_factory=list)
    expected_output: str = ""
    success_indicators: List[str] = field(default_factory=list)
    failure_indicators: List[str] = field(default_factory=list)


@dataclass
class AttackPath:
    """Complete attack path from recon to exploitation"""
    id: str
    name: str
    steps: List[AttackStep]
    target: Target
    score: float = 0.0
    success_probability: float = 0.0
    risk_level: Severity = Severity.MEDIUM


@dataclass
class Finding:
    """Security finding/vulnerability"""
    id: str
    title: str
    severity: Severity
    description: str
    affected_host: str
    affected_port: int = 0
    cvss_score: float = 0.0
    cve_id: str = ""
    exploit_available: bool = False
    remediation: str = ""
    evidence: str = ""
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "title": self.title,
            "severity": self.severity.name,
            "cvss_score": self.cvss_score,
            "cve_id": self.cve_id,
            "affected_host": self.affected_host,
            "affected_port": self.affected_port,
            "description": self.description,
            "exploit_available": self.exploit_available,
            "remediation": self.remediation,
            "timestamp": self.timestamp.isoformat()
        }


@dataclass
class PentestReport:
    """Complete penetration test report"""
    target: str
    start_time: datetime
    end_time: Optional[datetime] = None
    findings: List[Finding] = field(default_factory=list)
    attack_paths: List[AttackPath] = field(default_factory=list)
    executed_commands: List[Dict] = field(default_factory=list)
    scan_results: Dict[str, Any] = field(default_factory=dict)

    @property
    def critical_count(self) -> int:
        return len([f for f in self.findings if f.severity == Severity.CRITICAL])

    @property
    def high_count(self) -> int:
        return len([f for f in self.findings if f.severity == Severity.HIGH])

    @property
    def risk_score(self) -> float:
        """Calculate overall risk score (0-100)"""
        if not self.findings:
            return 0

        weights = {
            Severity.CRITICAL: 10,
            Severity.HIGH: 5,
            Severity.MEDIUM: 2,
            Severity.LOW: 1,
            Severity.INFO: 0.5
        }

        total = sum(weights[f.severity] for f in self.findings)
        return min(total, 100)

    def to_dict(self) -> Dict:
        return {
            "target": self.target,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "summary": {
                "total_findings": len(self.findings),
                "critical": self.critical_count,
                "high": self.high_count,
                "risk_score": self.risk_score,
                "attack_paths_found": len(self.attack_paths)
            },
            "findings": [f.to_dict() for f in self.findings],
            "attack_paths": [{"id": p.id, "name": p.name, "steps": len(p.steps)} for p in self.attack_paths]
        }


# =============================================================================
# TOOL REGISTRY
# =============================================================================

class ToolRegistry:
    """Registry of available security tools"""

    TOOLS: Dict[str, Tool] = {}

    @classmethod
    def register(cls, tool: Tool):
        cls.TOOLS[tool.name] = tool

    @classmethod
    def get(cls, name: str) -> Optional[Tool]:
        return cls.TOOLS.get(name)

    @classmethod
    def get_by_category(cls, category: ToolCategory) -> List[Tool]:
        return [t for t in cls.TOOLS.values() if t.category == category]

    @classmethod
    def is_available(cls, name: str) -> bool:
        tool = cls.TOOLS.get(name)
        if not tool:
            return False
        return shutil.which(tool.command.split()[0]) is not None


# Register common tools
def _parse_nmap(output: str) -> Dict:
    """Parse nmap output"""
    ports = []
    for line in output.split('\n'):
        match = re.match(r'(\d+)/(tcp|udp)\s+(\w+)\s+(.+)', line)
        if match:
            ports.append({
                "port": int(match.group(1)),
                "protocol": match.group(2),
                "state": match.group(3),
                "service": match.group(4)
            })
    return {"ports": ports}


def _parse_nikto(output: str) -> Dict:
    """Parse nikto output"""
    findings = []
    for line in output.split('\n'):
        if '+ ' in line and 'OSVDB' in line:
            findings.append(line.strip())
    return {"findings": findings}


def _parse_ffuf(output: str) -> Dict:
    """Parse ffuf output"""
    paths = []
    for line in output.split('\n'):
        match = re.search(r'"url":\s*"([^"]+)"', line)
        if match:
            paths.append(match.group(1))
    return {"paths": paths}


ToolRegistry.register(Tool(
    name="nmap",
    category=ToolCategory.NETWORK,
    command="nmap",
    args_template="-sV -sC -p- {target}",
    output_parser=_parse_nmap,
    description="Network port scanner"
))

ToolRegistry.register(Tool(
    name="nikto",
    category=ToolCategory.WEB,
    command="nikto",
    args_template="-h {target}",
    output_parser=_parse_nikto,
    description="Web server scanner"
))

ToolRegistry.register(Tool(
    name="ffuf",
    category=ToolCategory.WEB,
    command="ffuf",
    args_template="-u {target}/FUZZ -w ~/.claude-home/BlackBox/external-tools/SecLists/Discovery/Web-Content/common.txt -o - -of json",
    output_parser=_parse_ffuf,
    description="Web fuzzer"
))

ToolRegistry.register(Tool(
    name="nuclei",
    category=ToolCategory.WEB,
    command="nuclei",
    args_template="-u {target} -severity medium,high,critical -json",
    output_parser=lambda x: json.loads(x) if x.strip() else {},
    description="Vulnerability scanner"
))


# =============================================================================
# MCTS ATTACK PATH PLANNER
# =============================================================================

class MCTSNode:
    """Monte Carlo Tree Search node for attack planning"""

    def __init__(
        self,
        step: Optional[AttackStep] = None,
        parent: Optional['MCTSNode'] = None
    ):
        self.step = step
        self.parent = parent
        self.children: List[MCTSNode] = []
        self.visits = 0
        self.score = 0.0
        self.untried_actions: List[AttackStep] = []

    def ucb1(self, exploration: float = 1.41) -> float:
        """Upper Confidence Bound for Trees"""
        if self.visits == 0:
            return float('inf')
        exploitation = self.score / self.visits
        exploration_term = exploration * math.sqrt(
            math.log(self.parent.visits) / self.visits
        ) if self.parent else 0
        return exploitation + exploration_term

    def best_child(self) -> 'MCTSNode':
        return max(self.children, key=lambda c: c.ucb1())

    def add_child(self, step: AttackStep) -> 'MCTSNode':
        child = MCTSNode(step=step, parent=self)
        self.children.append(child)
        return child


class AttackPathPlanner:
    """
    MCTS-based attack path planning.

    Uses Monte Carlo Tree Search to find optimal attack sequences
    from reconnaissance to exploitation.
    """

    # Attack step templates by phase
    STEP_TEMPLATES = {
        AttackPhase.RECONNAISSANCE: [
            AttackStep(
                id="recon_dns", phase=AttackPhase.RECONNAISSANCE,
                tool="host", command="host {target}",
                description="DNS lookup"
            ),
            AttackStep(
                id="recon_whois", phase=AttackPhase.RECONNAISSANCE,
                tool="whois", command="whois {target}",
                description="WHOIS lookup"
            ),
        ],
        AttackPhase.SCANNING: [
            AttackStep(
                id="scan_ports", phase=AttackPhase.SCANNING,
                tool="nmap", command="nmap -sV -p- {target}",
                description="Full port scan",
                success_indicators=["open"]
            ),
            AttackStep(
                id="scan_vuln", phase=AttackPhase.SCANNING,
                tool="nmap", command="nmap --script vuln {target}",
                description="Vulnerability scan",
                success_indicators=["VULNERABLE"]
            ),
        ],
        AttackPhase.ENUMERATION: [
            AttackStep(
                id="enum_web", phase=AttackPhase.ENUMERATION,
                tool="ffuf", command="ffuf -u {target}/FUZZ -w wordlist.txt",
                description="Web directory enumeration",
                preconditions=["port_80_open", "port_443_open"]
            ),
            AttackStep(
                id="enum_smb", phase=AttackPhase.ENUMERATION,
                tool="smbclient", command="smbclient -L //{target} -N",
                description="SMB enumeration",
                preconditions=["port_445_open"]
            ),
        ],
        AttackPhase.VULNERABILITY_ANALYSIS: [
            AttackStep(
                id="vuln_nuclei", phase=AttackPhase.VULNERABILITY_ANALYSIS,
                tool="nuclei", command="nuclei -u {target} -severity high,critical",
                description="Nuclei vulnerability scan",
                success_indicators=["critical", "high"]
            ),
            AttackStep(
                id="vuln_nikto", phase=AttackPhase.VULNERABILITY_ANALYSIS,
                tool="nikto", command="nikto -h {target}",
                description="Nikto web scan",
                preconditions=["port_80_open"],
                success_indicators=["OSVDB"]
            ),
        ],
        AttackPhase.EXPLOITATION: [
            AttackStep(
                id="exploit_sqli", phase=AttackPhase.EXPLOITATION,
                tool="native_sqli", command="python -m tools.attacks sqli -u {target}",
                description="SQL injection test (native)",
                preconditions=["web_form_found"],
                success_indicators=["injectable", "vulnerable"]
            ),
        ],
    }

    def __init__(self, iterations: int = 100):
        self.iterations = iterations
        self.root: Optional[MCTSNode] = None

    def plan(self, target: Target, context: Dict[str, Any]) -> AttackPath:
        """
        Plan optimal attack path using MCTS.

        Args:
            target: Target information
            context: Current knowledge about target

        Returns:
            Optimal AttackPath
        """
        self.root = MCTSNode()
        self.root.untried_actions = self._get_initial_actions()

        for _ in range(self.iterations):
            node = self._select(self.root)
            if node.untried_actions:
                node = self._expand(node)
            score = self._simulate(node, context)
            self._backpropagate(node, score)

        # Extract best path
        path_steps = []
        node = self.root

        while node.children:
            node = max(node.children, key=lambda c: c.visits)
            if node.step:
                path_steps.append(node.step)

        return AttackPath(
            id=f"path_{datetime.now().strftime('%Y%m%d%H%M%S')}",
            name=f"Attack path for {target.host}",
            steps=path_steps,
            target=target,
            score=self.root.score / max(self.root.visits, 1)
        )

    def _get_initial_actions(self) -> List[AttackStep]:
        """Get actions for initial phase"""
        return self.STEP_TEMPLATES.get(AttackPhase.RECONNAISSANCE, [])

    def _get_next_actions(self, current_phase: AttackPhase) -> List[AttackStep]:
        """Get actions for next phase"""
        phases = list(AttackPhase)
        current_idx = phases.index(current_phase)
        if current_idx < len(phases) - 1:
            next_phase = phases[current_idx + 1]
            return self.STEP_TEMPLATES.get(next_phase, [])
        return []

    def _select(self, node: MCTSNode) -> MCTSNode:
        """Select node for expansion using UCB1"""
        while not node.untried_actions and node.children:
            node = node.best_child()
        return node

    def _expand(self, node: MCTSNode) -> MCTSNode:
        """Expand node with new action"""
        action = node.untried_actions.pop()
        child = node.add_child(action)
        child.untried_actions = self._get_next_actions(action.phase)
        return child

    def _simulate(self, node: MCTSNode, context: Dict) -> float:
        """Simulate attack path to estimate success"""
        score = 0.0
        current = node

        while current:
            if current.step:
                # Score based on phase progression
                phase_scores = {
                    AttackPhase.RECONNAISSANCE: 1,
                    AttackPhase.SCANNING: 2,
                    AttackPhase.ENUMERATION: 3,
                    AttackPhase.VULNERABILITY_ANALYSIS: 4,
                    AttackPhase.EXPLOITATION: 5
                }
                score += phase_scores.get(current.step.phase, 0)

                # Bonus for tool availability
                if ToolRegistry.is_available(current.step.tool):
                    score += 1

            current = current.parent

        # Randomize for exploration
        score += random.uniform(0, 2)
        return score

    def _backpropagate(self, node: MCTSNode, score: float):
        """Backpropagate score up the tree"""
        while node:
            node.visits += 1
            node.score += score
            node = node.parent


# =============================================================================
# REASONING MODULE
# =============================================================================

class ReasoningModule:
    """
    AI-powered reasoning for penetration testing decisions.

    Analyzes context, suggests next steps, and interprets results.
    """

    def __init__(self, llm_client: Optional[Callable] = None):
        self.llm_client = llm_client
        self.context: Dict[str, Any] = {}

    def update_context(self, key: str, value: Any):
        """Update reasoning context"""
        self.context[key] = value

    async def suggest_next_step(self, findings: List[Finding]) -> List[AttackStep]:
        """Suggest next steps based on current findings"""
        suggestions = []

        # Rule-based suggestions
        for finding in findings:
            if "SQL" in finding.title.upper():
                suggestions.append(AttackStep(
                    id="auto_sqli", phase=AttackPhase.EXPLOITATION,
                    tool="native_sqli", command=f"python -m tools.attacks sqli -u {finding.affected_host}",
                    description="Automated SQL injection exploitation (native)"
                ))

            if finding.cve_id:
                suggestions.append(AttackStep(
                    id=f"exploit_{finding.cve_id}",
                    phase=AttackPhase.EXPLOITATION,
                    tool="cve_search", command=f"python -m tools.intel cve {finding.cve_id}",
                    description=f"Search exploits for {finding.cve_id}"
                ))

        # LLM-based suggestions if available
        if self.llm_client:
            prompt = self._build_suggestion_prompt(findings)
            # Would call LLM here

        return suggestions

    def _build_suggestion_prompt(self, findings: List[Finding]) -> str:
        """Build prompt for LLM suggestion"""
        findings_text = "\n".join([
            f"- {f.title} ({f.severity.name}) on {f.affected_host}:{f.affected_port}"
            for f in findings
        ])

        return f"""Based on these penetration testing findings, suggest the next steps:

Findings:
{findings_text}

Current context:
{json.dumps(self.context, indent=2)}

Suggest 3 specific commands to run next, with explanations."""

    def interpret_results(self, tool: str, output: str) -> List[Finding]:
        """Interpret tool output and extract findings"""
        findings = []

        # Nmap interpretation
        if tool == "nmap":
            if "open" in output:
                for line in output.split('\n'):
                    match = re.match(r'(\d+)/(tcp|udp)\s+open\s+(.+)', line)
                    if match:
                        port = int(match.group(1))
                        service = match.group(3)

                        # Check for known vulnerable services
                        if "old" in service.lower() or "outdated" in output:
                            findings.append(Finding(
                                id=f"nmap_{port}",
                                title=f"Potentially outdated service on port {port}",
                                severity=Severity.MEDIUM,
                                affected_host=self.context.get("target", "unknown"),
                                affected_port=port,
                                description=f"Service: {service}",
                                remediation="Update to latest version"
                            ))

        # Nuclei interpretation
        if tool == "nuclei":
            try:
                for line in output.strip().split('\n'):
                    if line.strip():
                        data = json.loads(line)
                        severity_map = {
                            "critical": Severity.CRITICAL,
                            "high": Severity.HIGH,
                            "medium": Severity.MEDIUM,
                            "low": Severity.LOW,
                            "info": Severity.INFO
                        }

                        findings.append(Finding(
                            id=data.get("template-id", "unknown"),
                            title=data.get("info", {}).get("name", "Unknown"),
                            severity=severity_map.get(
                                data.get("info", {}).get("severity", "info"),
                                Severity.INFO
                            ),
                            affected_host=data.get("host", ""),
                            description=data.get("info", {}).get("description", ""),
                            cve_id=data.get("info", {}).get("cve-id", ""),
                            evidence=data.get("matched-at", "")
                        ))
            except json.JSONDecodeError:
                pass

        return findings


# =============================================================================
# COMMAND EXECUTOR
# =============================================================================

class CommandExecutor:
    """Safe command execution with sandboxing"""

    def __init__(self, timeout: int = 300, sandbox: bool = True):
        self.timeout = timeout
        self.sandbox = sandbox
        self.executed_commands: List[Dict] = []

    async def execute(
        self,
        command: str,
        requires_confirmation: bool = True
    ) -> Tuple[str, str, int]:
        """
        Execute command safely.

        Args:
            command: Command to execute
            requires_confirmation: Whether to require user confirmation

        Returns:
            Tuple of (stdout, stderr, return_code)
        """
        # Log command
        self.executed_commands.append({
            "command": command,
            "timestamp": datetime.now().isoformat(),
            "requires_confirmation": requires_confirmation
        })

        try:
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=self.timeout
            )

            return (
                stdout.decode('utf-8', errors='ignore'),
                stderr.decode('utf-8', errors='ignore'),
                process.returncode or 0
            )

        except asyncio.TimeoutError:
            return "", "Command timed out", -1
        except Exception as e:
            return "", str(e), -1


# =============================================================================
# MAIN AUTONOMOUS PENTEST AGENT
# =============================================================================

class AutonomousPentestAgent:
    """
    Autonomous Penetration Testing Agent

    Features:
    - MCTS-based attack path planning
    - AI-powered reasoning and decision making
    - Automatic tool selection and execution
    - Real-time finding analysis
    - Human-in-the-loop checkpoints
    """

    def __init__(
        self,
        target: str,
        llm_client: Optional[Callable] = None,
        autonomous: bool = False,
        timeout: int = 3600
    ):
        """
        Initialize pentest agent.

        Args:
            target: Target host/URL
            llm_client: Optional LLM for reasoning
            autonomous: Run fully autonomous (no confirmations)
            timeout: Overall timeout in seconds
        """
        self.target = target
        self.autonomous = autonomous
        self.timeout = timeout

        self.planner = AttackPathPlanner()
        self.reasoning = ReasoningModule(llm_client)
        self.executor = CommandExecutor(sandbox=not autonomous)

        self.findings: List[Finding] = []
        self.current_phase = AttackPhase.RECONNAISSANCE
        self.context: Dict[str, Any] = {"target": target}

    async def run(
        self,
        phases: Optional[List[AttackPhase]] = None,
        callback: Optional[Callable[[str, Any], Awaitable[None]]] = None
    ) -> PentestReport:
        """
        Run autonomous penetration test.

        Args:
            phases: Specific phases to run (all if None)
            callback: Progress callback (phase, data)

        Returns:
            PentestReport with all findings
        """
        report = PentestReport(
            target=self.target,
            start_time=datetime.now()
        )

        phases = phases or list(AttackPhase)

        try:
            for phase in phases:
                if callback:
                    await callback(f"Starting {phase.value}", {})

                self.current_phase = phase

                # Plan attack path for this phase
                target_obj = Target(host=self.target)
                path = self.planner.plan(target_obj, self.context)

                # Execute steps
                phase_steps = [s for s in path.steps if s.phase == phase]

                for step in phase_steps:
                    if not self._check_preconditions(step):
                        continue

                    if callback:
                        await callback(f"Executing: {step.description}", {"step": step.id})

                    # Execute step
                    command = step.command.replace("{target}", self.target)
                    stdout, stderr, code = await self.executor.execute(
                        command,
                        requires_confirmation=not self.autonomous
                    )

                    # Record execution
                    report.executed_commands.append({
                        "step": step.id,
                        "command": command,
                        "return_code": code,
                        "stdout_preview": stdout[:500] if stdout else ""
                    })

                    # Interpret results
                    new_findings = self.reasoning.interpret_results(step.tool, stdout)
                    self.findings.extend(new_findings)
                    report.findings.extend(new_findings)

                    # Update context
                    self._update_context_from_output(step.tool, stdout)

                    if callback:
                        await callback(
                            f"Step complete: {len(new_findings)} findings",
                            {"findings": len(new_findings)}
                        )

                # Get AI suggestions for next steps
                suggestions = await self.reasoning.suggest_next_step(self.findings)
                if suggestions and callback:
                    await callback(
                        f"AI suggests: {len(suggestions)} additional steps",
                        {"suggestions": [s.description for s in suggestions]}
                    )

            report.attack_paths.append(path)

        except Exception as e:
            logger.error(f"Pentest error: {e}")

        report.end_time = datetime.now()
        return report

    def _check_preconditions(self, step: AttackStep) -> bool:
        """Check if step preconditions are met"""
        for precondition in step.preconditions:
            if precondition.startswith("port_") and precondition.endswith("_open"):
                port = int(precondition.split("_")[1])
                if port not in self.context.get("open_ports", []):
                    return False
        return True

    def _update_context_from_output(self, tool: str, output: str):
        """Update context based on tool output"""
        if tool == "nmap":
            open_ports = []
            for line in output.split('\n'):
                match = re.match(r'(\d+)/(tcp|udp)\s+open', line)
                if match:
                    open_ports.append(int(match.group(1)))
            self.context["open_ports"] = open_ports

        self.reasoning.update_context("tool_outputs", {
            tool: output[:1000]
        })

    async def run_quick_scan(self) -> PentestReport:
        """Run quick reconnaissance and scanning only"""
        return await self.run(phases=[
            AttackPhase.RECONNAISSANCE,
            AttackPhase.SCANNING
        ])

    async def run_vuln_assessment(self) -> PentestReport:
        """Run vulnerability assessment (no exploitation)"""
        return await self.run(phases=[
            AttackPhase.RECONNAISSANCE,
            AttackPhase.SCANNING,
            AttackPhase.ENUMERATION,
            AttackPhase.VULNERABILITY_ANALYSIS
        ])


# =============================================================================
# CONVENIENCE FUNCTIONS
# =============================================================================

async def quick_pentest(target: str) -> PentestReport:
    """Quick penetration test (recon + scanning only)"""
    agent = AutonomousPentestAgent(target, autonomous=False)
    return await agent.run_quick_scan()


async def vuln_assessment(target: str) -> PentestReport:
    """Vulnerability assessment without exploitation"""
    agent = AutonomousPentestAgent(target, autonomous=False)
    return await agent.run_vuln_assessment()


async def full_pentest(
    target: str,
    autonomous: bool = False
) -> PentestReport:
    """Full penetration test"""
    agent = AutonomousPentestAgent(target, autonomous=autonomous)
    return await agent.run()


# =============================================================================
# EXAMPLE USAGE
# =============================================================================

if __name__ == "__main__":
    async def main():
        print("Autonomous Pentest Agent Demo")
        print("=" * 50)

        # Create agent
        agent = AutonomousPentestAgent(
            target="scanme.nmap.org",
            autonomous=False
        )

        # Run with progress callback
        async def progress(message: str, data: Dict):
            print(f"[*] {message}")
            if data:
                print(f"    Data: {data}")

        print("\nRunning quick scan...")
        report = await agent.run_quick_scan()

        print(f"\nResults:")
        print(f"Target: {report.target}")
        print(f"Duration: {(report.end_time - report.start_time).total_seconds():.1f}s")
        print(f"Findings: {len(report.findings)}")
        print(f"  Critical: {report.critical_count}")
        print(f"  High: {report.high_count}")
        print(f"Risk Score: {report.risk_score:.1f}/100")

        print(f"\nCommands Executed:")
        for cmd in report.executed_commands:
            print(f"  - {cmd.get('command', '')[:60]}...")

    asyncio.run(main())
